{"prompt":"View-Centric Context Modeling to Foster the Engineering of Cyber-Physical System Networks\n\nCyber-physical systems interact closely at runtime with their operational context, i.e., other systems, users, and external entities. Therefore, eliciting and documenting interactions with the operational context allows documenting rationales for design decisions, which is essential to define a system architecture that suits the system\u2019s purpose. For cyber-physical systems acting in system networks, this task becomes challenging since these networks can change at runtime, because individual systems can leave or join a network spontaneously. Hence, it becomes impossible to predict at design time the operational contexts at runtime. To aid context analysis and specification of such systems, this paper contributes a solution approach where the context of a system is not defined based on a static system boundary but depends on the specific intended use. We propose a view-centric perception of the operational context to leverage the functionality of external systems. This allows differentiating between functionality offered by the cyber-physical system network as a whole and the functionality provided by each individual system. An evaluation with an industrial case example and industry collaboration shows that this approach allows making suitable assumptions of the operational context at design time to guide architecture decisions.\n\n###\n\n","completion":" [\"Architectural Aspects\"]\n"}
{"prompt":"Trace {Link} {Recovery} for {Software} {Architecture} {Documentation}\n\nSoftware Architecture Documentation often consists of different artifacts. On the one hand, there is informal textual documentation. On the other hand, there are formal models of the system. Finding related information in multiple artifacts with different level of formality is often not easy. Therefore, trace links between these can help to understand the system. In this paper, we propose an extendable, agent-based framework for creating trace links between textual software architecture documentation and models. Our framework SWATTR offers different pipeline stages to extract text and model information, identify elements in text, and connect these elements to model elements. In each stage, multiple agents can be used to capture necessary information to automatically create trace links. We evaluate the performance of our approach with three case studies and compare our results to baseline approaches. The results for our approach are good to excellent with a weighted average \n                  \n                    \n                  \n                  $$F_1$$\n                  \n                -Score of 0.72 over all case studies. Moreover, our approach outperforms the baseline approaches on non-weighted average by at least 0.24 (weighted 0.31).\n\n###\n\n","completion":" [\"Architecture Analysis Method\"]\n"}
{"prompt":"An Exploratory Study of Naturalistic Decision Making in Complex Software Architecture Environments\n\nArchitects always make decisions in some context. That context shifts and changes dynamically. Different decision-making strategies are appropriate in different contexts. Architecture decisions are at times made under conditions of time pressure, high stakes, uncertainty, and with too little information. At other times, decision-makers have sufficient time to reflect on the decision and consider alternatives. Understanding context is critical to choosing appropriate approaches to architecture decision making. Naturalistic Decision Making (NDM) explains how people make decisions under real-world conditions. This paper investigates NDM in software architecture and studies architecture decisions in their environment and decision-making context. The research approach includes a case study of large technology organizations consisting of a survey, multiple focus groups, and participant observation. Previous studies that touch on NDM in software architecture have mainly focused on decision-making processes or tools or developing decision models. This paper provides three contributions. First, we build on previous studies by other researchers to produce an in-depth exploration of NDM in the context of software architecture. We focus on Recognition-Primed Decision (RPD) making as an implementation of NDM. Second, we present an examination of the decisions made by experienced architects under conditions that can be considered naturalistic. Third, we provide examples and recommendations that help software architects determine when an NDM approach is appropriate for their context.\n\n###\n\n","completion":" [\"Architecture Decision Making\"]\n"}
{"prompt":"Accurate Analysis of Quality Properties of Software with Observation-Based Markov Chain Refinement\n\nWe introduce a tool-supported method for the automated refinement of continuous-time Markov chains (CTMCs) used to assess quality properties of component-based software. Existing research focuses on improving the efficiency of CTMC analysis and on identifying new applications for this analysis. As such, ensuring that the analysis is accurate by using CTMCs that closely model the behaviour of the analysed software has received relatively little attention. Our new method addresses this gap by refining the high-level CTMC model of a component-based software system based on observations of the execution times of its components. Our refinement method reduced analysis errors by 77-90.3% for a service-based system implemented using six public web services from three different providers, improving the accuracy of the analysis and significantly reducing the risk of invalid software engineering decisions.\n\n###\n\n","completion":" [\"Architecture Analysis Method\"]\n"}
{"prompt":"{IAS:} An IoT Architectural Self-adaptation Framework\n\nThis paper develops a generic approach to model control loops and their interaction within the Internet of Things (IoT) environments. We take advantage of MAPE-K loops to enable architectural self-adaptation. The system\u2019s architectural setting is aligned with the adaptation goals and the components run-time situation and constraints. We introduce an integrated framework for IoT Architectural Self-adaptation (IAS) where functional control elements are in charge of environmental adaptation and autonomic control elements handle the functional system\u2019s architectural adaptation. A Queuing Networks (QN) approach was used for modeling the IAS. The IAS-QN can model control levels and their interaction to perform both architectural and environmental adaptations. The IAS-QN was modeled on a smart grid system for the Melle-Longchamp area (France). Our architectural adaptation approach successfully set the propositions to enhance the performance of the electricity transmission system. This industrial use-case is a part of CPS4EU European industrial innovation project (CPS4EU is a three years project funded by the H2020-ECSEL-2018-IA. The project develops four vital IoT technologies, namely computing, connectivity, sensing, and cooperative systems. It incorporates those IoT technologies through pre-integrated architectures and design tools. It instantiates the architectures in dedicated use-cases from a strategic application viewpoint for automotive, smart grid, and industrial automation\u00a0\n                  https:\/\/cps4eu.eu\n                  \n                ).\n\n\n###\n\n","completion":" [\"Architecture Optimization Method\"]\n"}
{"prompt":"An {Exploratory} {Study} on {Architectural} {Knowledge} in {Issue} {Tracking} {Systems}\n\nSoftware developers use issue trackers (e.g. Jira) to manage defects, bugs, tasks, change requests, etc. In this paper we explore (a) how architectural knowledge concepts (e.g. architectural component behavior, contextual constraints) are textually represented in issues (e.g. as adjectives), (b) which architectural knowledge concepts commonly occur in issues, and (c) which architectural knowledge concepts appear together. We analyzed issues in the Jira issue trackers of three large Apache projects. To identify \u201carchitecturally relevant\u201d issues, we linked issues to architecturally relevant source code changes in the studied systems. We then developed a code book by manually labeling a subset of issues. After reaching conceptual saturation, we coded remaining issues. Our findings support empirically-grounded search tools to identify architectural knowledge concepts in issues for future reuse.\n\n###\n\n","completion":" [\"Architecture Description\"]\n"}
{"prompt":"Anatomy, Concept, and Design Space of Blockchain Networks\n\nBlockchain technologies have been increasingly adopted by enterprises to increase operational efficiency and enable new business models. These enterprise blockchain applications generally run on dedicated blockchain networks due to regulations and security requirements. The design process of these networks involves many decisions and trade-offs that impact security, governance, and performance of applications that run on them. The challenge is further exacerbated by the lack of a common architecture and concept map to communicate about blockchain networks, as blockchain technologies tend to use different concepts and architecture. This paper presents a concept map, an anatomy and the principal dimensions of the design space of blockchain networks. We applied the proposed design space in a case study about designing and deploying a blockchain network for an ad-hoc IoT infrastructure. We found that the design space brought structure to the design process and the analysis of design alternatives. The presented concept map, anatomy and design space are intended to help improve the blockchain network design practice and lay a foundation for future research on the design process and deployment automation of blockchain networks.\n\n###\n\n","completion":" [\"Architecture Design Method\"]\n"}
{"prompt":"A Decision Model for Choosing Patterns in Blockchain-Based Applications\n\nBlockchains have been applied in different domains to guarantee data integrity and provide a decentralized computational infrastructure for executing smart contracts. Multiple blockchain-related patterns have been summarized by academics and industry practitioners covering different aspects, such as engineering applications on top of a blockchain, structuring smart contracts, and security. The existence of these patterns is both helpful and challenging for designers. Helpful, as the existence of these patterns means that developers do not need to recreate solutions to common problems. Challenging, as the multitude of patterns leaves a designer confused about when to adopt or adapt patterns. In this paper, we propose a decision model that assists developers and architects in selecting appropriate patterns for blockchain-based applications. The selection is based on the characteristics of the use cases and trade-offs implicit in the patterns. We evaluated the proposed decision model based on expert opinion regarding its correctness and usefulness in guiding the architecture design and understanding the rationale of various design decisions.\n\n###\n\n","completion":" [\"Architecture Decision Making\"]\n"}
{"prompt":"Employment of Optimal Approximations on Apache Hadoop Checkpoint Technique for Performance Improvements\n\nThe Checkpoint and Recovery (CR) technique is widely used due to its fault tolerance efficiency. The Apache Hadoop framework uses this technique as a way to avoid failures in its distributed file system. However, determining the optimal interval between successive checkpoints is a challenge, mainly inside Hadoop as it does not allow real-time modifications. The Dynamic Configuration Architecture (DCA) was created to solve this issue by enabling changes in the checkpoint period without any interruption of the Hadoop services. This paper presents improvements for the DCA through the configuration of the Hadoop checkpoint period in real-time based on optimal period approximations that were already endorsed by the literature. The proposed improvement depends on the tracking of the system resources. The data collected from these resources are stored in a history of attributes: a tree of monitored elements where data is updated as new observations are experienced in the system. This feature enables the user to estimate system factors so that our solution computes the checkpoints costs and the mean time between failures (MTBF). For the validation, experiments with transient failure in the NameNode were created and the usage of the history of attributes was tested in different scenarios. The evaluation results show that an adaptive configuration of checkpoint periods reduces the wasted time caused by failures in the NameNode and improves Hadoop performance. Also, the history of attributes demonstrated its value by providing an efficient way to estimate the system factors.\n\n###\n\n","completion":" [\"Architecture Optimization Method\"]\n"}
{"prompt":"{REST} vs GraphQL: {A} Controlled Experiment\n\nGraphQL is a novel query language for implementing service-based software architectures. The language is gaining momentum and it is now used by major software companies, such as Facebook and GitHub. However, we still lack empirical evidence on the real gains achieved by GraphQL, particularly in terms of the effort required to implement queries in this language. Therefore, in this paper we describe a controlled experiment with 22 students (10 undergraduate and 12 graduate), who were asked to implement eight queries for accessing a web service, using GraphQL and REST. Our results show that GraphQL requires less effort to implement remote service queries when compared to REST (9 vs 6 minutes, median times). These gains increase when REST queries include more complex endpoints, with several parameters. Interestingly, GraphQL outperforms REST even among more experienced participants (as is the case of graduate students) and among participants with previous experience in REST, but no previous experience in GraphQL.\n\n###\n\n","completion":" [\"Architecture Design Method\"]\n"}
{"prompt":"Determining Microservice Boundaries: {A} Case Study Using Static and Dynamic Software Analysis\n\nA number of approaches have been proposed to identify service boundaries when decomposing a monolith to microservices. However, only a few use systematic methods and have been demonstrated with replicable empirical studies. We describe a systematic approach for refactoring systems to microservice architectures that uses static analysis to determine the system\u2019s structure and dynamic analysis to understand its actual behavior. A prototype of a tool was built using this approach (MonoBreaker) and was used to conduct a case study on a real-world software project. The goal was to assess the feasibility and benefits of a systematic approach to decomposition that combines static and dynamic analysis. The three study participants regarded as positive the decomposition proposed by our tool, and considered that it showed improvements over approaches that rely only on static analysis.\n\n###\n\n","completion":" [\"Architecture Design Method\"]\n"}
{"prompt":"Empowering SysML-Based Software Architecture Description with Formal Verification: From SysADL to {CSP}\n\nSoftware architecture description languages (ADLs) currently adopted by industry for software-intensive systems are largely semi-formal and essentially based on SysML and specialized profiles. Despite these ADLs allow describing both structure and behavior of the architecture, there is no guarantee regarding the satisfaction of correctness properties. Due to their nature, semi-formal ADLs do not support automated verification of the specified properties, in particular those related to safety and liveness of the specified behavior. This paper proposes a novel approach for empowering SysML-based ADLs with formal verification support founded on model checking. It presents (i) how the semantics of SysADL, a SysML-based ADL, can be formalized in terms of the CSP process calculus, (ii) how correctness properties can be formally specified in CSP, and (iii) how the FDR4 refinement checker allows verifying correctness properties through model checking. The automated model transformation from SysADL architecture descriptions to CSP composite processes has been implemented as a plug-in\u00a0to the Eclipse-based SysADL Studio tool. This paper also describes an application of SysADL empowered with CSP to validate its usefulness in practice.\n\n###\n\n","completion":" [\"Architecture Description Language\"]\n"}
{"prompt":"Identifying and Prioritizing Architectural Debt Through Architectural Smells: {A} Case Study in a Large Software Company\n\nArchitectural technical debt can have a huge impact on software maintainability and evolution. Hence, different architectural violations, detected as architectural smells, need to be identified and refactored. In this paper, we conducted a multiple case-study on several architectural smells detected in four industrial projects. We conducted an in-depth investigation with a questionnaire, interviews and thorough inspection of the code with the practitioners. We evaluated the negative impact of the technical debt detected by the architectural smells, their difficulty to be refactored and the usefulness of the detection tool. The results show that practitioners appreciated the help of automatic detection, and that they prioritize refactoring architectural debt that causes more negative impact despite the higher refactoring effort.\n\n###\n\n","completion":" [\"Architecture Pattern\"]\n"}
{"prompt":"Enforcing Architectural Security Decisions\n\nSoftware architects should specify security measures for a software system on an architectural level. However, the implementation often diverges from this intended architecture including its security measures. This may lead to severe vulnerabilities that have a wide impact on the system and are hard to fix afterwards. In this paper, we propose an approach for checking the implementation's conformance with the defined security measures using architectural security rules: We extend a controlled natural language approach to formalize these rules and use dynamic analysis techniques to extract information on the actual system behavior for the conformance check. We evaluate our approach by an industrial case study to show the applicability and flexibility of our conformance checking approach.\n\n###\n\n","completion":" [\"Architecture Analysis Method\"]\n"}
{"prompt":"Predicting the Performance of Privacy-Preserving Data Analytics Using Architecture Modelling and Simulation\n\nPrivacy-preserving data analytics is an emerging technology which allows multiple parties to perform joint data analytics without disclosing source data to each other or a trusted third-party. A variety of platforms and protocols have been proposed in this domain. However, these systems are not yet widely used, and little is known about them from a software architecture and performance perspective. Here we investigate the feasibility of using architectural performance modelling and simulation tools for predicting the performance of privacy-preserving data analytics systems. We report on a lab-based experimental study of a privacy-preserving credit scoring application that uses an implementation of a partial homomorphic encryption scheme. The main experiments are on the impact of analytic problem size (number of data items and number of features), and cryptographic key length for the overall system performance. Our modelling approach performed with a relative error consistently under 5\\% when predicting the median learning time for the scoring application. We find that the use of this approach is feasible in this technology domain, and discuss how it can support architectural decision making on trade-offs between properties such as performance, cost, and security. We expect this to enable the evaluation and optimisation of privacy-preserving data analytics technologies.\n\n###\n\n","completion":" [\"Architectural Assumptions\"]\n"}
{"prompt":"InMap: Automated Interactive Code-to-Architecture Mapping Recommendations\n\nReflexion Modelling is a popular method used in industry for Software Architectural Consistency Checking (SACC). However, it involves a mapping step that is manual and tedious. There exist techniques and tools that attempt to automate mapping, yet they are either limited in their approach or they require an initial set of manually pre-mapped entities. This study proposes a novel technique, InMap, that improves the mapping process in reflexion modelling by both providing versatility and eliminating the constraint of needing a set of manually pre-mapped entities in order to automate mapping. Using a software\u2019s architecture descriptions, InMap applies information retrieval concepts to the software\u2019s source code to interactively provide mapping recommendations to an architect. For the six systems InMap was evaluated on, the recommendations it provided achieved an average recall of 0.97, and an average precision of 0.82. InMap also achieved higher, f\n<inf xmlns:mml=\"http:\/\/www.w3.org\/1998\/Math\/MathML\" xmlns:xlink=\"http:\/\/www.w3.org\/1999\/xlink\">1<\/inf>\n-scores in comparison to existing techniques that require premapping. This provides a basis for improving industry tools that use reflexion modelling or similar SACC methods.\n\n###\n\n","completion":" [\"Architecture Optimization Method\"]\n"}
{"prompt":"Recovering Architectural Design Decisions\n\nDesigning and maintaining a software system's architecture typically involve making numerous design decisions, each potentially affecting the system's functional and nonfunctional properties. Understanding these design decisions can help inform future decisions and implementation choices and can avoid introducing regressions and architectural inefficiencies later. Unfortunately, design decisions are rarely well documented and are typically a lost artifact of the architecture creation and maintenance process. The loss of this information can thus hurt development. To address this shortcoming, we develop RecovAr, a technique for automatically recovering design decisions from the project's readily available history artifacts, such as an issue tracker and version control repository. RecovAr uses state-of-the-art architectural recovery techniques on a series of version control commits and maps those commits to issues to identify decisions that affect system architecture. While some decisions can still be lost through this process, our evaluation on Hadoop and Struts, two large open-source systems with over 8 years of development each and, on average, more than 1 million lines of code, shows that RecovAr has the recall of 75% and a precision of 77%. Our work formally defines architectural design decisions and develops an approach for tracing such decisions in project histories. Additionally, the work introduces methods to classify whether decisions are architectural and to map decisions to code elements. Finally, our work contributes a methodology engineers can follow to preserve design-decision knowledge in their projects.\n\n###\n\n","completion":" [\"Architecture Decision Making\"]\n"}
{"prompt":"A Framework for Tunable Anomaly Detection\n\nAs software architecture practice relies more and more on runtime data to inform decisions in continuous experimentation and self-adaptation, it is increasingly important to consider the quality of the data used as input to the different decision-making and prediction algorithms. One issue in data-driven decisions is that real-life data coming from running systems can contain invalid or wrong values which can bias the result of data analysis. Data-driven decision-making should therefore comprise detection and handling of data anomalies as an integral part of the process. However, currently, anomaly detection is either absent in runtime decision-making approaches for continuous experimentation and self-adaptation or difficult to tailor to domain-specific needs. In this paper, we contribute by proposing a framework that simplifies the detection of data anomalies in timeseries-outputs of running systems. The framework is generic, since it can be employed in different domains, and tunable, since it uses expert user input in tailoring anomaly detection to the needs and assumptions of each domain. We evaluate the feasibility of the framework by successfully applying it to detecting anomalies in a real-life timeseries dataset from the traffic domain.\n\n###\n\n","completion":" [\"Architecture Decision Making\"]\n"}
{"prompt":"Decentralized Architecture for Energy-Aware Service Assembly\n\nContemporary application domains make more and more appealing the vision of applications built as a dynamic and opportunistic assembly of autonomous and independent resources. However, the adoption of such paradigm is challenged by: (i) the openness and scalability needs of the operating environment, which rule out approaches based on centralized architectures and, (ii) the increasing concern for sustainability issues, which makes particularly relevant, in addition to QoS constraints, the goal of reducing the application energy footprint. In this context, we contribute by proposing a decentralized architecture to build a fully functional assembly of distributed services, able to optimize its energy consumption, paying also attention to issues concerning the delivered quality of service. We suggest suitable indexes to measure from different perspectives the energy efficiency of the resulting assembly, and present the results of extensive simulation experiments to assess the effectiveness of our approach.\n\n###\n\n","completion":" [\"Architecture Design Method\"]\n"}
{"prompt":"Synthesis and Quantitative Verification of Tradeoff Spaces for Families of Software Systems\n\nDesigning software subject to uncertainty in a way that provides guarantees about its run-time behavior while achieving an acceptable balance between multiple extra-functional properties is still an open problem. Tools and techniques to inform engineers about poorly-understood design spaces in the presence of uncertainty are needed. To tackle this problem, we propose an approach that combines synthesis of spaces of system design alternatives from formal specifications of architectural styles with probabilistic formal verification. The main contribution of this paper is a formal framework for specification-driven synthesis and analysis of design spaces that provides formal guarantees about the correctness of system behaviors and satisfies quantitative properties (e.g., defined over system qualities) subject to uncertainty, which is factored as a first-class entity.\n\n###\n\n","completion":" [\"Architecture Design Method\"]\n"}
{"prompt":"Applying Architecture-Based Adaptation to Automate the Management of Internet-of-Things\n\nArchitecture-based adaptation equips a software-intensive system with a feedback loop that enables the system to adapt itself at runtime to changes to maintain its required quality goals. To guarantee the required goals, existing adaptation approaches apply exhaustive verification techniques at runtime. However these approaches are restricted to small-scale settings, which often limits their applicability in practice. To tackle this problem, we introduce an innovative architecture-based adaptation approach to solve a concrete practical problem of VersaSense: automating the management of Internet-of-Things (IoT). The approach, called MARTAS, equips a software system with a feedback loop that employs Models At Run Time and Statistical techniques to reason about the system and adapt it to ensure the required goals. We apply MARTAS to a building security case system, which is a representative IoT system deployed by VersaSense. The application comprises a set of IoT devices that communicate sensor data over a time synchronized smart mess network to a central monitoring facility. We demonstrate how MARTAS outperforms a conservative approach that is typically applied in practice and a state-of-the-art adaptation approach for different quality goals, and we report lessons learned from this industrial case.\n\n###\n\n","completion":" [\"Architecture Optimization Method\"]\n"}
{"prompt":"Exploiting Architecture\/Runtime Model-Driven Traceability for Performance Improvement\n\nModel-Driven Engineering techniques may achieve a major support to the software development when they allow to manage relationships between a running system and its architectural model. These relationships can be exploited for different goals, such as the software evolution due to new functional requirements. In this paper, we define and use relationships that work as support to the performance improvement of a running system. In particular, we combine: (i) a bidirectional model transformation framework tailored to define relationships between performance monitoring data and an architectural model, with (ii) a technique for detecting performance antipatterns and for suggesting architectural changes, aimed at removing performance problems identified on the basis of runtime information. The result is an integrated approach that exploits traceability relationships between the monitoring data and the architectural model to derive recommended refactoring solutions for the system performance improvement. The approach has been applied to an e-commerce application based on microservices that has been designed by means of UML software models profiled with MARTE.\n\n###\n\n","completion":" [\"Architecture Analysis Method\", \"Architecture Design Method\"]\n"}
{"prompt":"Availability-Driven Architectural Change Propagation Through Bidirectional Model Transformations Between {UML} and Petri Net Models\n\nSoftware architecture is nowadays subject to frequent changes due to multiple reasons, such as evolution induced by new requirements. Architectural changes driven by non-functional requirements are particularly difficult to identify, because they attain quantitative analyses that are usually carried out with specific languages and tools. A considerable number of approaches, based on model transformations, have been proposed in the last decades to derive non-functional models from software architectural descriptions. However, there is a clear lack of automation in the backward path that brings the analysis results back to the software architecture. In this paper we address this problem in the context of software availability. We introduce a bidirectional model transformation between UML State Machines (SM), annotated with availability properties, and Generalized Stochastic Petri Nets (GSPN). Such transformation, implemented in the JTL language, is used both to derive a GSPN-based availability model from a SM-based software architecture and, after the analysis, to propagate back on the SM the changes carried out on the GSPN. We demonstrate the effectiveness of our approach on an Environmental Control System to which we apply well-known fault tolerance patterns aimed at improving its software availability.\n\n###\n\n","completion":" [\"Architecture Analysis Method\"]\n"}
{"prompt":"Architectural Design Decisions for Systems Supporting Model-Based Analysis of Runtime Events: {A} Qualitative Multi-method Study\n\nModels are popular artefacts in the software development process which promise to improve stakeholder communication and the overall quality of a software system under construction. Recent research proposes that the usefulness of models is not limited only to the software design phase: Empirical evidence indicates that manual analysis of a running system is improved when models are linked to recorded runtime events. However, software architects are confronted with various design decisions when designing a system that yields the required runtime events and correlates them to the model elements they originate from. The contribution of this paper is a taxonomy of architectural design decisions distilled from a series of qualitative studies following a multi-method research study design: We utilized coding techniques from Grounded Theory to build an initial taxonomy from architectural concepts found in the literature, and verified and extended the taxonomy independently by five novice software architects in a practical scenario. The resulting taxonomy captures essential architectural decisions when implementing a system that supports the analysis of its runtime behaviour using models. We then performed initial steps towards a architectural guidance model by applying the taxonomy to another realistic scenario, following the Design Science Research method, in order to analyze the properties and deepen our own technical understanding of the captured concepts in the taxonomy.\n\n###\n\n","completion":" [\"Architecture Decision Making\"]\n"}
{"prompt":"The Anatomy of a Large-Scale Experimentation Platform\n\nOnline controlled experiments (e.g., A\/B tests) are an integral part of successful data-driven companies. At Microsoft, supporting experimentation poses a unique challenge due to the wide variety of products being developed, along with the fact that experimentation capabilities had to be added to existing, mature products with codebases that go back decades. This paper describes the Microsoft ExP Platform (ExP for short) which enables trustworthy A\/B experimentation at scale for products across Microsoft, from web properties (such as bing.com) to mobile apps to device drivers within the Windows operating system. The two core tenets of the platform are trustworthiness (an experiment is meaningful only if its results can be trusted) and scalability (we aspire to expose every single change in any product through an A\/B experiment). Currently, over ten thousand experiments are run annually. In this paper, we describe the four core components of an A\/B experimentation system: experimentation portal, experiment execution service, log processing service and analysis service, and explain the reasoning behind the design choices made. These four components work together to provide a system where ideas can turn into experiments within minutes and those experiments can provide initial trustworthy results within hours.\n\n###\n\n","completion":" [\"Architecture Description\"]\n"}
{"prompt":"A {Runtime} {Safety} {Enforcement} {Approach} by {Monitoring} and {Adaptation}\n\nThe use of models and formal analysis techniques at runtime is fundamental to address safety assurance during the system operational stage, when all relevant uncertainties and unknowns can be resolved. This paper presents a novel approach to runtime safety enforcement of software systems based on the MAPE-K control loop architecture for system monitoring and control, and on the Abstract State Machine as runtime model representing the enforcement strategy aimed at preserving or eventually restoring safety. The enforcer software is designed as an autonomic manager that wraps around the software system to monitor and manage unsafe system changes using probing and effecting interfaces provided by the system, so realising grey-box safety enforcement. The proposed approach is supported by a component framework that is here illustrated by means of a case study in the health-care domain.\n\n###\n\n","completion":" [\"Architecture Design Method\"]\n"}
{"prompt":"Mitigating the Influence of Embedded Software Development Environments and Toolsets {(ESDT)} on Software Architecture\n\nOne of the first tasks in engineering embedded systems is the selection of the hardware; more specifically, the MicroController Units (MCUs). This selection is driven by business, technical, organizational, and legal constraints. Often, the hardware is delivered together with proprietary environments in which the software to be deployed has to be developed. This imposes architecturally significant constraints that are usually communicated inappropriately (in terms of time and format) to the engineering team. Examples are the usage of proprietary data types and programming language constructs (e.g., macros in C) and limitations to the reuse of existing software assets. To overcome this challenge, we propose an approach that has two main constituents: (i) the Embedded System Checklist, which aims at guiding the selection of MCUs according to the architecture constraints; and (ii) the Embedded System ESDT Dependency (SED) Architecture View, which connects the software design view with the technical view, describing hardware-related development environment limitations and their influences on the software architecture. We evaluated the application of these concepts in two industrial projects and show that making these dependencies transparent saves a lot of effort during software system development.\n\n###\n\n","completion":" [\"Architecture Design Method\"]\n"}
{"prompt":"Mapping Features to Source Code through Product Line Architecture: Traceability and Conformance\n\nExisting software product line approaches often develop and evolve product line features, architecture, and source code independently, which makes it difficult to manage the relationship and conformance between these artifacts. This paper presents a novel approach using the architecture as a pivot to address this problem. It consists of a modeling mechanism that integrates features specification into an architectural model, and an architecture-implementation mapping mechanism that combines code generation with annotation processing. The approach can trace a product line feature to the architecture and source code, and automatically update the architecture and source code to maintain their conformance when feature changes occur. We implemented an Eclipse-based toolset to support the approach, and conducted a case study with the Apache Solr open-source system. The result shows that our approach is both applicable and capable to support the development and evolution of real-world variations of a software system.\n\n###\n\n","completion":" [\"Architecture Design Method\"]\n"}
{"prompt":"Two Architectural Threat Analysis Techniques Compared\n\nIn an initial attempt to systematize the research field of architectural threat analysis, this paper presents a comparative study of two threat analysis techniques. In particular, the controlled experiment presented here compares two variants of Microsoft\u2019s STRIDE. The two variants differ in the way the analysis is performed. In one case, each component of the software system is considered in isolation and scrutinized for potential security threats. In the other case, the analysis has a wider scope and considers the security threats that might occur in a pair of interacting software components. The study compares the techniques with respect to their effectiveness in finding security threats (benefits) as well as the time that it takes to perform the analysis (cost). We also look into other human aspects which are important for industrial adoption, like, for instance, the perceived difficulty in learning and applying the techniques as well as the overall preference of our experimental participants.\n\n###\n\n","completion":" [\"Architecture Analysis Method\"]\n"}
{"prompt":"Synchronous Reconfiguration of Distributed Embedded Applications During Operation\n\nSpeed of adaptation to changing demand is a critical success factor in factory automation. The key to speed is to enable agile development by independent engineer offices and equipment producers with industrial-grade microservice architectures. The expensive drawback is: While software components evolve over time, manufacturers have to integrate and deploy more and more updates during costly production stops. To avoid production stops as much as possible, we propose reconfiguration extensions to a real-time container architecture proposed earlier. The original container approach addresses both the functional and nonfunctional aspects of integrating embedded software components in late engineering phases. The extended approach allows modifications of the running distributed embedded application even during operation, while continuously ensuring reactivity of the system. The agents running on each node prepare the reconfiguration in background and then synchronously perform the required modifications according to a detailed reconfiguration plan. We demonstrate our concept by describing a synchronous API change between two distributed software components of a running gesture recognition system. An evaluation shows the feasibility of the concepts, but also calls for further research.\n\n###\n\n","completion":" [\"Architectural Aspects\"]\n"}
{"prompt":"A Taxonomy of Blockchain-Based Systems for Architecture Design\n\nBlockchain is an emerging technology for decentralised and transactional data sharing across a large network of untrusted participants. It enables new forms of distributed software architectures, where agreement on shared states can be established without trusting a central integration point. A major difficulty for architects designing applications based on blockchain is that the technology has many configurations and variants. Since blockchains are at an early stage, there is little product data or reliable technology evaluation available to compare different blockchains. In this paper, we propose how to classify and compare blockchains and blockchain-based systems to assist with the design and assessment of their impact on software architectures. Our taxonomy captures major architectural characteristics of blockchains and the impact of their principal design decisions. This taxonomy is intended to help with important architectural considerations about the performance and quality attributes of blockchain-based systems.\n\n###\n\n","completion":" [\"Architecture Decision Making\"]\n"}
