{"prompt":"Supporting Architectural Decision Making on Data Management in Microservice Architectures\n\nToday many service-based systems follow the microservice architecture style. As microservices are used to build distributed systems and promote architecture properties such as independent service development, polyglot technology stacks including polyglot persistence, and loosely coupled dependencies, architecting data management is crucial in most microservice architectures. Many patterns and practices for microservice data management architectures have been proposed, but are today mainly informally discussed in the so-called \u201cgrey literature\u201d: practitioner blogs, experience reports, and system documentations. As a result, the architectural knowledge is scattered across many knowledge sources that are usually based on personal experiences, inconsistent, and, when studied on their own, incomplete. In this paper we report on a qualitative, in-depth study of 35 practitioner descriptions of best practices and patterns on microservice data management architectures. Following a model-based qualitative research method, we derived a formal architecture decision model containing 325 elements and relations. Comparing the completeness of our model with an existing pattern catalog, we conclude that our architectural decision model substantially reduces the effort needed to sufficiently understand microservice data management decisions, as well as the uncertainty in the design process.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Pattern\": \"An architectural pattern is a general, reusable solution to a commonly occurring problem in software architecture within a given context. Patterns with negative effects on the product, i.e., anti-patterns, are also included here.\"}, \"Research Object\": [\"Architecture Pattern\"]}\n"}
{"prompt":"View-Centric Context Modeling to Foster the Engineering of Cyber-Physical System Networks\n\nCyber-physical systems interact closely at runtime with their operational context, i.e., other systems, users, and external entities. Therefore, eliciting and documenting interactions with the operational context allows documenting rationales for design decisions, which is essential to define a system architecture that suits the system\u2019s purpose. For cyber-physical systems acting in system networks, this task becomes challenging since these networks can change at runtime, because individual systems can leave or join a network spontaneously. Hence, it becomes impossible to predict at design time the operational contexts at runtime. To aid context analysis and specification of such systems, this paper contributes a solution approach where the context of a system is not defined based on a static system boundary but depends on the specific intended use. We propose a view-centric perception of the operational context to leverage the functionality of external systems. This allows differentiating between functionality offered by the cyber-physical system network as a whole and the functionality provided by each individual system. An evaluation with an industrial case example and industry collaboration shows that this approach allows making suitable assumptions of the operational context at design time to guide architecture decisions.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architectural Aspects\": \"A method for identifying or specifying specific architectural aspects in existing implemented architectures, e.g., automatically identifying transactional contexts in an architecture. Note that if you analyze an architecture description containing these aspects, the analysis is a separate research object.\"}, \"Research Object\": [\"Architectural Aspects\"]}\n"}
{"prompt":"Model-Based Analysis of Microservice Resiliency Patterns\n\nMicroservice application developers try to mitigate the impact of partial outages typically by implementing service-to-service interactions that use well-known resiliency patterns, such as Retry, Fail Fast, and Circuit Breaker. However, those resiliency patterns-as well as their available open-source implementations-are often documented informally, leaving it up to application developers to figure out when and how to use those patterns in the context of a particular microservice application. In this paper, we take a first step towards improving on this situation by introducing a model checking-based approach in which we use the PRISM probabilistic model checker to analyze the behavior of the Retry and Circuit Breaker resiliency patterns as continuous-time Markov chains (CTMC). This approach has enabled us to quantify the impact of applying each resiliency pattern on multiple quality attributes, as well as to determine how to best tune their parameters to deal with varying service availability conditions, in the context of a simple client-service interaction scenario.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Analysis Method\": \"A method for analyzing existing software architectures, e.g., to measure or evaluate specific qualities or functions.\", \"Architecture Pattern\": \"An architectural pattern is a general, reusable solution to a commonly occurring problem in software architecture within a given context. Patterns with negative effects on the product, i.e., anti-patterns, are also included here.\"}, \"Research Object\": [\"Architecture Pattern\", \"Architecture Analysis Method\"]}\n"}
{"prompt":"An Architecture-Driven Adaptation Approach for Big Data Cyber Security Analytics\n\nBig Data Cyber Security Analytics (BDCA) systems leverage big data technologies (e.g., Hadoop and Spark) for collecting, storing, and analyzing large volume of security event data to detect cyber-attacks. Accuracy and response time are the two most important quality concerns for BDCA systems. However, the frequent changes in the operating environment of a BDCA system (such as quality and quantity of security event data) significantly impact these qualities. In this paper, we first study the impact of such environmental changes. We then present ADABTics, an architecture-driven adaptation approach that (re)composes the system at runtime with a set of components to ensure optimal accuracy and response time. We finally evaluate our approach both in a single node and multinode settings using a Hadoop-based BDCA system and different adaptation scenarios. Our evaluation shows that on average ADABTics improves BDCA's accuracy and response time by 6.06% and 23.7\n<sup xmlns:mml=\"http:\/\/www.w3.org\/1998\/Math\/MathML\" xmlns:xlink=\"http:\/\/www.w3.org\/1999\/xlink\">%<\/sup>\n respectively.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Optimization Method\": \"A method to optimize existing architectures (implemented or designed) regarding specific qualities or properties.\"}, \"Research Object\": [\"Architecture Optimization Method\"]}\n"}
{"prompt":"Experiments in Curation: Towards Machine-Assisted Construction of Software Architecture Knowledge Bases\n\nSoftware architects inhabit a complex, rapidly evolving technological landscape. An ever growing collection of competing architecturally significant technologies, ranging from distributed databases to middleware and cloud platforms, makes rigorously comparing alternatives and selecting appropriate solutions a daunting engineering task. To address this problem, we envisage an ecosystem of curated, automatically updated knowledge bases that enable straightforward and streamlined technical comparisons of related products. These knowledge bases would emulate engineering handbooks that are commonly found in other engineering disciplines. As a first step towards this vision, we have built a curated knowledge base for comparing distributed databases based on a semantically defined feature taxonomy. We report in this paper on the initial results of using supervised machine learning to assist with knowledge base curation. Our results show immense promise in recommending Web pages that are highly relevant to curators. We also describe the major obstacles, both practical and scientific, that our work has uncovered. These must be overcome by future research in order to make our vision of curated knowledge bases a reality.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Decision Making\": \"In software development and evolution, decision-making is an integral part. Various decisions are being made throughout the software development life cycle concerning processes, products, tools, methods, and techniques. From a decision-making perspective, all these questions are confronted by different objectives and constraints, a huge number of variables under dynamically changing requirements, processes, actors, stakeholders, tools, and techniques. This is combined with incomplete, fuzzy or inconsistent information about all the involved artifacts. [Ruhe2003]\"}, \"Research Object\": [\"Architecture Decision Making\"]}\n"}
{"prompt":"Exploring Web Search Engines to Find Architectural Knowledge\n\nSoftware engineers need relevant and up-to-date architectural knowledge (AK), in order to make well-founded design decisions. However, finding such AK is quite challenging. One pragmatic approach is to search for AK on the web using traditional search engines (e.g. Google); this is common practice among software engineers. Still, we know very little about what AK is retrieved, from where, and how useful it is. In this paper, we conduct an empirical study with 53 software engineers, who used Google to make design decisions using the Attribute-Driven-Design method. Based on how the subjects assessed the nature and relevance of the retrieved results, we determined how effective web search engines are to find relevant architectural information. Moreover, we identified the different sources of AK on the web and their associated AK concepts.\n\n\n\n###\n\n","completion":" {\"Explanations\": {}, \"Research Object\": [\"Architecture Design Decisions\"]}\n"}
{"prompt":"Architectural Concerns for Digital Twin of the Organization\n\nEmploying a Digital Twin of the Organization would help enterprises to change and innovate, thus enhancing their organization\u2019s sustainability. However, the lack of engineering best practices for developing and operating a Digital Twin of the Organization makes it difficult for enterprises to fully benefit from it. Many companies are currently investigating the potential use of it, but available solutions are often context-dependent or system-specific, and challenging to adapt, extend, and reuse. Therefore, digitalization is perceived as a slow, resource-demanding, and extremely expensive process whose outcome is uncertain. To this extent, enterprises seek solutions allowing them to gently introduce a Digital Twin of the Organization into their organization and to evolve it according to the changing needs and situations. This paper reports a first attempt on architecting a Digital Twin of an Organization, and discusses some architectural concerns to be addressed in order to facilitate its development and evolution.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Evolution\": \"The process of maintaining and adapting existing software architecture to meet requirements and environmental changes [Imran et al., 2016]. This includes papers that investigate the evolution of specific architectures.\"}, \"Research Object\": [\"Architecture Evolution\"]}\n"}
{"prompt":"Architecture-Centric Support for Integrating Security Tools in a Security Orchestration Platform\n\nSecurity Operation Centers (SOC) leverage a number of tools to detect, thwart and deal with security attacks. One of the key challenges of SOC is to quickly integrate security tools and operational activities. To address this challenge, an increasing number of organizations are using Security Orchestration, Automation and Response (SOAR) platforms, whose design needs suitable architectural support. This paper presents our work on architecture-centric support for designing a SOAR platform. Our approach consists of a conceptual map of SOAR platform and the key dimensions of an architecture design space. We have demonstrated the use of the approach in designing and implementing a Proof of Concept (PoC) SOAR platform for (i) automated integration of security tools and (ii) automated interpretation of activities to execute incident response processes. We also report a preliminary evaluation of the proposed architectural support for improving a SOAR\u2019s design.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Reference Architecture\": \"A description of an architecture (e.g., domain-specific or to solve recurring problems) that can be tailored to specific use cases.\"}, \"Research Object\": [\"Reference Architecture\"]}\n"}
{"prompt":"Continuous Experimentation for Automotive Software on the Example of a Heavy Commercial Vehicle in Daily Operation\n\nAs the automotive industry focuses its attention more and more towards the software functionality of vehicles, techniques to deliver new software value at a fast pace are needed. Continuous Experimentation, a practice coming from the web-based systems world, is one of such techniques. It enables researchers and developers to use real-world data to verify their hypothesis and steer the software evolution based on performances and user preferences, reducing the reliance on simulations and guesswork. Several challenges prevent the verbatim adoption of this practice on automotive cyber-physical systems, e.g., safety concerns and limitations from computational resources; nonetheless, the automotive field is starting to take interest in this technique. This work aims at demonstrating and evaluating a prototypical Continuous Experimentation infrastructure, implemented on a distributed computational system housed in a commercial truck tractor that is used in daily operations by a logistic company on public roads. The system comprises computing units and sensors, and software deployment and data retrieval are only possible remotely via a mobile data connection due to the commercial interests of the logistics company. This study shows that the proposed experimentation process resulted in the development team being able to base software development choices on the real-world data collected during the experimental procedure. Additionally, a set of previously identified design criteria to enable Continuous Experimentation on automotive systems was discussed and their validity confirmed in the light of the presented work.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Description\": \"An Architecture Description (AD) is a work product used to express the Architecture of some System Of Interest. An AD describes one possible Architecture for a System Of Interest. An AD may take the form of a document, a set of models, a model repository, or some other form [ISO\/IEC 42010]. Papers use existing architecture description languages to describe architectures.\", \"Architecture Design Method\": \"A method for designing software architectures, e.g., to obtain specific qualities or functions.\"}, \"Research Object\": [\"Architecture Description\", \"Architecture Design Method\"]}\n"}
{"prompt":"DesignDiff: Continuously Modeling Software Design Difference from Code Revisions\n\nThe design structure of a system continuously evolves as the consequence of fast-paced code revisions. Agile techniques, such as continuous testing, ensures the function goals of a system with every code revision. However, there lacks an efficient approach that can continuously model the design difference resulting from every single code revision to facilitate comprehension and ensure the design quality. This paper contributes a novel design modeling approach, called Design Differencing (DESIGNDIFF), that models and visualizes the highlevel design differences resulting from every code revision. This paper defines a complete and general set of 17 design change operators to capture the design difference from any code revision. We evaluated the potential of DESIGNDIFF in three aspects. First, a user study of 10 developers indicated that DESIGNDIFF can help practitioners to faster and better understand high-level design differences from real-life software commits. Second, DESIGNDIFF analyzed 14,832 real-life commits in five real-life projects: finding 4,189 commits altered the software design, 855 commits introduced and 337 commits eliminated design flaws. The latency between the flaw introduction and elimination is on average 2 months to 2 years! With an affordable performance overhead, DESIGNDIFF has great potential to benefit practitioners in more applications.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Description Language\": \"A formal or software language to create a description of a software architecture, i.e., \\\"any form of expression for use in architecture descriptions\\\" [ISO\/IEC 42010]. Papers propose or extend an existing architecture description language.\"}, \"Research Object\": [\"Architecture Description Language\"]}\n"}
{"prompt":"A Generic and Highly Scalable Framework for the Automation and Execution of Scientific Data Processing and Simulation Workflows\n\nIn order to perform complex data processing and co-simulation workflows for research on data driven energy systems, a generic, modular and highly scalable process operation framework is presented in this article. This framework consistently applies web technologies to build up a microservices architecture. It automates the startup, synchronization, and management of scientific data processing and simulation tools (e.g. Python, Matlab, OpenModelica) as part of larger transdisciplinary, multi-domain data processing and co-simulation workflows. It uses container virtualization on the underlying cluster computing environment to control and manage different simulation nodes.Within the framework's processing workflow, software executables can be distributed to different nodes on the cluster, easily access data and communicate with other components via communication adapters and a high-performance messaging channel infrastructure. By integrating Apache NiFi, the framework also provides an easy-to-use web user interface to allow users to model, perform and operate workflows for future energy system solutions. As soon as a complex workflow is set up in the process operation framework, researchers can use the workflow without any setup or configuration on their local workstations and without knowing any details of the underlying infrastructure or software environment.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Description\": \"An Architecture Description (AD) is a work product used to express the Architecture of some System Of Interest. An AD describes one possible Architecture for a System Of Interest. An AD may take the form of a document, a set of models, a model repository, or some other form [ISO\/IEC 42010]. Papers use existing architecture description languages to describe architectures.\"}, \"Research Object\": [\"Architecture Description\"]}\n"}
{"prompt":"Explaining {Architectural} {Design} {Tradeoff} {Spaces}: {A} {Machine} {Learning} {Approach}\n\nIn software design, guaranteeing the correctness of run-time system behavior while achieving an acceptable balance among multiple quality attributes remains a challenging problem. Moreover, providing guarantees about the satisfaction of those requirements when systems are subject to uncertain environments is even more challenging. While recent developments in architectural analysis techniques can assist architects in exploring the satisfaction of quantitative guarantees across the design space, existing approaches are still limited because they do not explicitly link design decisions to satisfaction of quality requirements. Furthermore, the amount of information they yield can be overwhelming to a human designer, making it difficult to distinguish the forest through the trees. In this paper, we present an approach to analyzing architectural design spaces that addresses these limitations and provides a basis to enable the explainability of design tradeoffs. Our approach combines dimensionality reduction techniques employed in machine learning pipelines with quantitative verification to enable architects to understand how design decisions contribute to the satisfaction of strict quantitative guarantees under uncertainty across the design space. Our results show feasibility of the approach in two case studies and evidence that dimensionality reduction is a viable approach to facilitate comprehension of tradeoffs in poorly-understood design spaces.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Optimization Method\": \"A method to optimize existing architectures (implemented or designed) regarding specific qualities or properties.\"}, \"Research Object\": [\"Architecture Optimization Method\"]}\n"}
{"prompt":"Decentralized Architecture for Energy-Aware Service Assembly\n\nContemporary application domains make more and more appealing the vision of applications built as a dynamic and opportunistic assembly of autonomous and independent resources. However, the adoption of such paradigm is challenged by: (i) the openness and scalability needs of the operating environment, which rule out approaches based on centralized architectures and, (ii) the increasing concern for sustainability issues, which makes particularly relevant, in addition to QoS constraints, the goal of reducing the application energy footprint. In this context, we contribute by proposing a decentralized architecture to build a fully functional assembly of distributed services, able to optimize its energy consumption, paying also attention to issues concerning the delivered quality of service. We suggest suitable indexes to measure from different perspectives the energy efficiency of the resulting assembly, and present the results of extensive simulation experiments to assess the effectiveness of our approach.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Design Method\": \"A method for designing software architectures, e.g., to obtain specific qualities or functions.\"}, \"Research Object\": [\"Architecture Design Method\"]}\n"}
{"prompt":"Architectural Decay as Predictor of Issue- and Change-Proneness\n\nArchitectural decay imposes real costs in terms of developer effort, system correctness, and performance. Over time, those problems are likely to be revealed as explicit implementation issues (defects, feature changes, etc.). Recent empirical studies have demonstrated that there is a significant correlation between architectural \"smells\"\u2014manifestations of architectural decay\u2014and implementation issues. In this paper, we take a step further in exploring this phenomenon. We analyze the available development data from 10 open-source software systems and show that information regarding current architectural decay in these systems can be used to build models that accurately predict future issue-proneness and change-proneness of the systems\u2019 implementations. As a less intuitive result, we also show that, in cases where historical data for a system is unavailable, such data from other, unrelated systems can provide reasonably accurate issue- and change-proneness prediction capabilities.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Technical Debt\": \"In software-intensive systems, technical debt consists of design or implementation constructs that are expedient in the short term, but set up a technical context that can make a future change more costly or impossible. Technical debt is a contingent liability whose impact is limited to internal system qualities, primarily maintainability and evolvability.\"}, \"Research Object\": [\"Technical Debt\"]}\n"}
{"prompt":"Safety Analysis Method for Cooperative Driving Systems\n\nThis paper researches safety analysis for a cooperative driving system. The main objective is to assess how cooperative elements in an ISO 26262 item definition affect safety goals. The architectural model of a cooperative adaptive cruise control system is developed and its functional safety is analyzed using a combination of fault tree analysis and fault classification methods. The results show that inclusion of cooperative architecture perspective affects the safety goals of cooperative adaptive cruise control because ASIL determination is influenced by vehicle-to-vehicle communication faults.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Analysis Method\": \"A method for analyzing existing software architectures, e.g., to measure or evaluate specific qualities or functions.\"}, \"Research Object\": [\"Architecture Analysis Method\"]}\n"}
{"prompt":"Empirical Insights into the Evolving Role of Architects in Decision-Making in an Agile Context\n\nThe transition to agile software development changes the decision-making power in organizations. This study aims to provide researchers and practitioners with empirical insights into how the participation in decision-making by enterprise, solution and system architects evolves due to this transition. For this purpose, a case study was conducted to examine the participation of and challenges for architects in decision-making in agile projects. A mixed-method research approach was used comprising observations, conversations, interviews, literature study and a survey. We found that 101 decision types are used prior to and in agile iterations, in which architects and stakeholders collaborate to make these decisions. The projection of these types of decisions over 25 different actors in the case study organization demonstrates that decision-making is a group effort in which solution and system architects are highly involved. Architecture and agility can indeed co-exist. Another finding of this case study is that stakeholders in agile teams perceive less architecture involvement in decision-making and expect less design decisions up front. Architects are challenged to become team players, to make design decisions only when they are necessary, and finally, to document, communicate, and share design decisions more effectively.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Decision Making\": \"In software development and evolution, decision-making is an integral part. Various decisions are being made throughout the software development life cycle concerning processes, products, tools, methods, and techniques. From a decision-making perspective, all these questions are confronted by different objectives and constraints, a huge number of variables under dynamically changing requirements, processes, actors, stakeholders, tools, and techniques. This is combined with incomplete, fuzzy or inconsistent information about all the involved artifacts. [Ruhe2003]\"}, \"Research Object\": [\"Architecture Decision Making\"]}\n"}
{"prompt":"Guiding Architectural Decision Making on Service Mesh Based Microservice Architectures\n\nMicroservices are becoming the de-facto standard way for software development in the cloud and in service-oriented computing. Service meshes have been introduced as a dedicated infrastructure for managing a network of containerized microservices, in order to cope with the complexity, manageability, and interoperability challenges in especially large-scale microservice architectures. Unfortunately so far no dedicated architecture guidance for designing microservices and choosing among technology options in a service mesh exist. As a result, there is a substantial uncertainty in designing and using microservices in a service mesh environment today. To alleviate this problem, we have performed a model-based qualitative in-depth study of existing practices in this field in which we have systematically and in-depth studied 40 reports of established practices from practitioners. In our study we modeled our findings in a rigorously specified reusable architectural decision model, in which we identified 14 architectural design decisions with 47 decision outcomes and 77 decision drivers in\u00a0total. We estimated the uncertainty in the resulting design space with and without use of our model, and found that a substantial uncertainty reduction can be potentially achieved by applying our model.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Decision Making\": \"In software development and evolution, decision-making is an integral part. Various decisions are being made throughout the software development life cycle concerning processes, products, tools, methods, and techniques. From a decision-making perspective, all these questions are confronted by different objectives and constraints, a huge number of variables under dynamically changing requirements, processes, actors, stakeholders, tools, and techniques. This is combined with incomplete, fuzzy or inconsistent information about all the involved artifacts. [Ruhe2003]\"}, \"Research Object\": [\"Architecture Decision Making\"]}\n"}
{"prompt":"A {DSL} for {MAPE} Patterns Representation in Self-adapting Systems\n\nIn architecture-based self-adaptation, the adaptation logic is usually structured in terms of MAPE-K (Monitor-Analyze-Plan-Execute over a shared Knowledge) control loops dealing with the adaptation concerns of the managed system. In case of large, complex and decentralized systems, multiple interacting MAPE loops are introduced. Some common design patterns of interactive MAPE components have been proposed in the literature; however, a well-defined way to document them and to express the semantics of their interactions is still missing. This paper presents a domain-specific language, MAPE Specification Language (MSL), as modeling front-end to define and instantiate common patterns of interacting MAPE components when architecting the adaptation logic of a self-adaptive system. We also provide a semantic mapping (implemented by a model generator) to transform MSL descriptions of MAPE pattern instances into formal executable models based on the formalism of self-adaptive Abstract State Machines (ASMs). Such a mapping provides a link to the modeling back-end of ASMs for formally specifying and analyzing the behavior of instances of MAPE patterns.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Description Language\": \"A formal or software language to create a description of a software architecture, i.e., \\\"any form of expression for use in architecture descriptions\\\" [ISO\/IEC 42010]. Papers propose or extend an existing architecture description language.\"}, \"Research Object\": [\"Architecture Description Language\"]}\n"}
{"prompt":"Technical Architectures for Automotive Systems\n\nDriven by software, the automotive domain is living an unprecedented revolution with original equipment manufacturers increasingly becoming software companies. Vehicle electrical and electronic software architectures are considered means for addressing several concerns, which span from safety to security, through electrification and autonomy. Such architectures serve also as pivotal means for enabling communication between an original equipment manufacturer and suppliers (tier 1 and 2 companies) within the automotive ecosystem. In the automotive domain, software architectures include (at least) three different views of descending abstraction: functional, logical, and technical. In this work, we focus on the technical view with a two-folded contribution. On the one hand, we propose a feature model of technical architectures for automotive systems. On the other hand, starting from the elicited feature model, we present three technical reference architectures able to guide three generations of automotive systems. We evaluate the contribution of this work by means of a focus group validation session and short semi-structured interviews with automotive experts and practitioners.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architectural Aspects\": \"A method for identifying or specifying specific architectural aspects in existing implemented architectures, e.g., automatically identifying transactional contexts in an architecture. Note that if you analyze an architecture description containing these aspects, the analysis is a separate research object.\", \"Reference Architecture\": \"A description of an architecture (e.g., domain-specific or to solve recurring problems) that can be tailored to specific use cases.\"}, \"Research Object\": [\"Architectural Aspects\", \"Reference Architecture\"]}\n"}
{"prompt":"Using Informal Knowledge for Improving Software Quality Trade-Off Decisions\n\nTo deliver high-quality software, in a software development process a variety of quality attributes must be considered such as performance, usability or security. In particular, quality attributes such as security and usability are difficult to analyze quantitatively. Knowledge about such quality attributes is often only informally available and therefore cannot be processed in structured and formalized decision-making approaches to optimize the software architecture. In this paper, we have defined a framework in order to make use of informally available knowledge in automated design decision support processes. We connect qualitative reasoning models with models for quantitative quality estimation to optimize software architectures regarding both knowledge representation models together. By our approach quality attributes for which no quantitative evaluation model is available can now be used in automated software architecture optimization approaches. For evaluating our approach, we demonstrate its benefits using a real-world case study and an example that is related to a real-world system.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Evolution\": \"The process of maintaining and adapting existing software architecture to meet requirements and environmental changes [Imran et al., 2016]. This includes papers that investigate the evolution of specific architectures.\"}, \"Research Object\": [\"Architecture Evolution\"]}\n"}
{"prompt":"Quantum Computing Platforms: Assessing the Impact on Quality Attributes and {SDLC} Activities\n\nPractical quantum computing is rapidly becoming a reality. To harness quantum computers\u2019 real potential in software applications, one needs to have an in-depth understanding of all such characteristics of quantum computing platforms (QCPs), relevant from the Software Engineering (SE) perspective. Restrictions on copying, deletion, the transmission of qubit states, a hard dependency on quantum algorithms are few, out of many, examples of QCP characteristics that have significant implications for building quantum software.Thus, developing quantum software requires a paradigm shift in thinking by software engineers. This paper presents the key findings from the SE perspective, resulting from an in-depth examination of state-of-the-art QCPs available today. The main contributions that we present include i) Proposing a general architecture of the QCPs, ii) Proposing a programming model for developing quantum software, iii) Determining architecturally significant characteristics of QCPs, and iv) Determining the impact of these characteristics on various Quality Attributes (QAs) and Software Development Life Cycle (SDLC) activities.We show that the nature of QCPs makes them useful mainly in specialized application areas such as scientific computing. Except for performance and scalability, most of the other QAs (e.g., maintainability, testability, and reliability) are adversely affected by different characteristics of a QCP.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Reference Architecture\": \"A description of an architecture (e.g., domain-specific or to solve recurring problems) that can be tailored to specific use cases.\"}, \"Research Object\": [\"Reference Architecture\"]}\n"}
{"prompt":"Availability-Driven Architectural Change Propagation Through Bidirectional Model Transformations Between {UML} and Petri Net Models\n\nSoftware architecture is nowadays subject to frequent changes due to multiple reasons, such as evolution induced by new requirements. Architectural changes driven by non-functional requirements are particularly difficult to identify, because they attain quantitative analyses that are usually carried out with specific languages and tools. A considerable number of approaches, based on model transformations, have been proposed in the last decades to derive non-functional models from software architectural descriptions. However, there is a clear lack of automation in the backward path that brings the analysis results back to the software architecture. In this paper we address this problem in the context of software availability. We introduce a bidirectional model transformation between UML State Machines (SM), annotated with availability properties, and Generalized Stochastic Petri Nets (GSPN). Such transformation, implemented in the JTL language, is used both to derive a GSPN-based availability model from a SM-based software architecture and, after the analysis, to propagate back on the SM the changes carried out on the GSPN. We demonstrate the effectiveness of our approach on an Environmental Control System to which we apply well-known fault tolerance patterns aimed at improving its software availability.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Analysis Method\": \"A method for analyzing existing software architectures, e.g., to measure or evaluate specific qualities or functions.\"}, \"Research Object\": [\"Architecture Analysis Method\"]}\n"}
{"prompt":"Towards a Reference Architecture for Cloud-Based Plant Genotyping and Phenotyping Analysis Frameworks\n\nThe domain of plant genotyping and phenotyping presents a number of challenges in the area of large data computation. Various tools and systems have been developed to automate the scientific workflows and support the computational needs of this domain. In this paper, we review a number of the popular systems (i.e., Galaxy, iPlant, GenAp and LemnaTec) in the domain of plant genotyping and phenotyping using the scenario-based architectural analysis method (SAAM). In particular, we focus on how different stakeholders are using these systems in a variety of scenarios and to what extent the systems support their needs. Our SAAM analysis shows that the existing systems have shortcomings. For example, they are limited in their support for high throughput processing of large amounts of heterogeneous types of data. Based on our findings we propose a reference architecture along with a preliminary evaluation in the subject domain. The reference architecture and its evaluation is aimed at helping developers\/architects create suitable architectural designs and select appropriate technologies when developing plant phenotyping and genotyping systems.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Description\": \"An Architecture Description (AD) is a work product used to express the Architecture of some System Of Interest. An AD describes one possible Architecture for a System Of Interest. An AD may take the form of a document, a set of models, a model repository, or some other form [ISO\/IEC 42010]. Papers use existing architecture description languages to describe architectures.\", \"Reference Architecture\": \"A description of an architecture (e.g., domain-specific or to solve recurring problems) that can be tailored to specific use cases.\"}, \"Research Object\": [\"Reference Architecture\", \"Architecture Description\"]}\n"}
{"prompt":"Abstraction Layered Architecture: Writing Maintainable Embedded Code\n\nThe brisk pace of the growth in embedded technology depends largely on how fast we can write and maintain software contained within embedded devices. Every enterprise seeks to improve its productivity through maintainability. While many avenues for improvement exist, highly maintainable code bases that can stay that way over a long time are rare. This article proposes a reference software architecture for embedded systems aimed at improving long-term maintainability. This reference architecture, called the Abstraction Layered Architecture (ALA), is built on the existing body of knowledge in software architecture and more than two decades of experience in designing embedded software at Tru-Test Group, New Zealand. ALA can be used for almost any object-oriented software project, and strongly supports domain-specific abstractions such as those found in most embedded software.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Reference Architecture\": \"A description of an architecture (e.g., domain-specific or to solve recurring problems) that can be tailored to specific use cases.\"}, \"Research Object\": [\"Reference Architecture\"]}\n"}
{"prompt":"The Anatomy of a Large-Scale Experimentation Platform\n\nOnline controlled experiments (e.g., A\/B tests) are an integral part of successful data-driven companies. At Microsoft, supporting experimentation poses a unique challenge due to the wide variety of products being developed, along with the fact that experimentation capabilities had to be added to existing, mature products with codebases that go back decades. This paper describes the Microsoft ExP Platform (ExP for short) which enables trustworthy A\/B experimentation at scale for products across Microsoft, from web properties (such as bing.com) to mobile apps to device drivers within the Windows operating system. The two core tenets of the platform are trustworthiness (an experiment is meaningful only if its results can be trusted) and scalability (we aspire to expose every single change in any product through an A\/B experiment). Currently, over ten thousand experiments are run annually. In this paper, we describe the four core components of an A\/B experimentation system: experimentation portal, experiment execution service, log processing service and analysis service, and explain the reasoning behind the design choices made. These four components work together to provide a system where ideas can turn into experiments within minutes and those experiments can provide initial trustworthy results within hours.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Description\": \"An Architecture Description (AD) is a work product used to express the Architecture of some System Of Interest. An AD describes one possible Architecture for a System Of Interest. An AD may take the form of a document, a set of models, a model repository, or some other form [ISO\/IEC 42010]. Papers use existing architecture description languages to describe architectures.\"}, \"Research Object\": [\"Architecture Description\"]}\n"}
{"prompt":"Architectural Design Decisions for Systems Supporting Model-Based Analysis of Runtime Events: {A} Qualitative Multi-method Study\n\nModels are popular artefacts in the software development process which promise to improve stakeholder communication and the overall quality of a software system under construction. Recent research proposes that the usefulness of models is not limited only to the software design phase: Empirical evidence indicates that manual analysis of a running system is improved when models are linked to recorded runtime events. However, software architects are confronted with various design decisions when designing a system that yields the required runtime events and correlates them to the model elements they originate from. The contribution of this paper is a taxonomy of architectural design decisions distilled from a series of qualitative studies following a multi-method research study design: We utilized coding techniques from Grounded Theory to build an initial taxonomy from architectural concepts found in the literature, and verified and extended the taxonomy independently by five novice software architects in a practical scenario. The resulting taxonomy captures essential architectural decisions when implementing a system that supports the analysis of its runtime behaviour using models. We then performed initial steps towards a architectural guidance model by applying the taxonomy to another realistic scenario, following the Design Science Research method, in order to analyze the properties and deepen our own technical understanding of the captured concepts in the taxonomy.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Decision Making\": \"In software development and evolution, decision-making is an integral part. Various decisions are being made throughout the software development life cycle concerning processes, products, tools, methods, and techniques. From a decision-making perspective, all these questions are confronted by different objectives and constraints, a huge number of variables under dynamically changing requirements, processes, actors, stakeholders, tools, and techniques. This is combined with incomplete, fuzzy or inconsistent information about all the involved artifacts. [Ruhe2003]\"}, \"Research Object\": [\"Architecture Decision Making\"]}\n"}
{"prompt":"Optimising Architectures for Performance, Cost, and Security\n\nDeciding on the optimal architecture of a software system is difficult, as the number of design alternatives and component interactions can be overwhelmingly large. Adding security considerations can make architecture evaluation even more challenging. Existing model-based approaches for architecture optimisation usually focus on performance and cost constraints. This paper proposes a model-based architecture optimisation approach that advances the state-of-the-art by adding security constraints. The proposed approach is implemented in a prototype tool, by extending Palladio Component Model (PCM) and PerOpteryx. Through a laboratory-based evaluation study of a multi-party confidential data analytics system, we show how our tool discovers secure architectural design options on the Pareto frontier of cost and performance.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Optimization Method\": \"A method to optimize existing architectures (implemented or designed) regarding specific qualities or properties.\"}, \"Research Object\": [\"Architecture Optimization Method\"]}\n"}
{"prompt":"Understanding Architecture Decisions in Context - An Industry Case Study of Architects' Decision-Making Context\n\nMany organizations struggle with efficient architecture decision-making approaches. Often, the decision-making approaches are not articulated or understood. This problem is particularly evident in large, globally distributed organizations with multiple large products and systems. The significant architecture decisions of a system are a critical organization knowledge asset, as well as a determinant of success. However, the environment in which decisions get made, recorded, and followed-up on often confounds rather than helps articulation and execution of architecture decisions. This paper looks at aspects of architecture decision-making, drawing from an industry-based case study. The data represents findings from a qualitative case study involving a survey and three focus groups across multiple organizations in a global technology company. Architects in this organization are responsible for multiple products and systems, where individual products can include up to 50+ teams. The impact is not just on others in the system; architecture decisions also impact other decisions and other architects. The findings suggest recommendations for organizations to improve how they make and manage architecture decisions. In particular, this paper notes the relevance of group decision-making, decision scope, and social factors such as trust in effective architecture decision-making.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Decision Making\": \"In software development and evolution, decision-making is an integral part. Various decisions are being made throughout the software development life cycle concerning processes, products, tools, methods, and techniques. From a decision-making perspective, all these questions are confronted by different objectives and constraints, a huge number of variables under dynamically changing requirements, processes, actors, stakeholders, tools, and techniques. This is combined with incomplete, fuzzy or inconsistent information about all the involved artifacts. [Ruhe2003]\"}, \"Research Object\": [\"Architecture Decision Making\"]}\n"}
{"prompt":"A Complexity Metric for Microservices Architecture Migration\n\nMonolith applications tend to be difficult to deploy, upgrade, maintain, and understand. Microservices, on the other hand, have the advantages of being independently developed, tested, deployed, scaled and, more importantly, easier to change and maintain. This paper addresses the problem of migrating a monolith to a microservices architecture. Therefore, we address two research questions: (1) Can we define the cost of decomposition in terms of the effort to redesign a functionality, which is implemented in the monolith as an ACID transaction, into several distributed transactions? (2) Considering several similarity measures between domain entities, which provide a better decomposition when they are compared using the proposed complexity metric? To answer the first research question, we propose a complexity metric, for each functionality of the monolith application, that measures the impact of relaxing the functionality consistency on the architecture redesign and implementation. Regarding the second research question, we experiment with four similarity measures, each based on a different type of information collected from monolith functionality implementation. We evaluated our approach with three monolith systems and compared our complexity metric against industry metrics of cohesion and coupling. We also evaluated the different similarity measures in terms of the complexity of the decomposition they produce. We were able to correctly correlate the complexity metric with other metrics of cohesion and coupling defined in other research and we conclude that no single combination of similarity measures outperforms the other, which is confirmed by the existing research. Additionally, we conclude that the approach can help on an incremental migration to microservices, which, actually, is the strategy proposed by the industry experts.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Design Method\": \"A method for designing software architectures, e.g., to obtain specific qualities or functions.\"}, \"Research Object\": [\"Architecture Design Method\"]}\n"}
{"prompt":"Aligning Architecture with Business Goals in the Automotive Domain\n\nWhen designing complex automotive systems in practice, employed technologies and architectural decisions need to reflect business goals. While the software architecture community has acknowledged the need to align business goals with architectural decisions, there is a lack of practical approaches to achieve this alignment. In this paper, we intend to close this gap by providing a systematic approach for architecture-business alignment. The approach describes how to align architecture with business concerns by eliciting goals, identifying quality attributes, and deriving architectural tactics. We iteratively developed and evaluated the approach together with an international automotive manufacturer. We show the application of the proposed approach within our participating company leveraging a use case related to software-over-the-air technologies. The proposed approach is perceived as beneficial by our participants, since it provides a structured mechanism to align architecture and business goals by determining key architectural concerns as quality attributes and tactics.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Design Method\": \"A method for designing software architectures, e.g., to obtain specific qualities or functions.\"}, \"Research Object\": [\"Architecture Design Method\"]}\n"}
{"prompt":"Flaws in Flows: Unveiling Design Flaws via Information Flow Analysis\n\nThis paper presents a practical and formal approach to analyze security-centric information flow policies at the level of the design model. Specifically, we focus on data confidentiality and data integrity objectives. In its guiding principles, the approach is meant to be amenable for designers (e.g., software architects) that have very limited or no background in formal models, logics, and the like. To this aim, we provide an intuitive graphical notation, which is based on the familiar Data Flow Diagrams, and which requires as little effort as possible in terms of extra security-centric information the designer has to provide. The result of the analysis algorithm is the early discovery of design flaws in the form of violations of the intended security properties. The approach is implemented as a publicly available plugin for Eclipse and evaluated with four real-world case studies from publicly available literature.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Analysis Method\": \"A method for analyzing existing software architectures, e.g., to measure or evaluate specific qualities or functions.\"}, \"Research Object\": [\"Architecture Analysis Method\"]}\n"}
{"prompt":"Trace {Link} {Recovery} for {Software} {Architecture} {Documentation}\n\nSoftware Architecture Documentation often consists of different artifacts. On the one hand, there is informal textual documentation. On the other hand, there are formal models of the system. Finding related information in multiple artifacts with different level of formality is often not easy. Therefore, trace links between these can help to understand the system. In this paper, we propose an extendable, agent-based framework for creating trace links between textual software architecture documentation and models. Our framework SWATTR offers different pipeline stages to extract text and model information, identify elements in text, and connect these elements to model elements. In each stage, multiple agents can be used to capture necessary information to automatically create trace links. We evaluate the performance of our approach with three case studies and compare our results to baseline approaches. The results for our approach are good to excellent with a weighted average \n                  \n                    \n                  \n                  $$F_1$$\n                  \n                -Score of 0.72 over all case studies. Moreover, our approach outperforms the baseline approaches on non-weighted average by at least 0.24 (weighted 0.31).\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Analysis Method\": \"A method for analyzing existing software architectures, e.g., to measure or evaluate specific qualities or functions.\"}, \"Research Object\": [\"Architecture Analysis Method\"]}\n"}
{"prompt":"Automated Microservice Identification in Legacy Systems with Functional and Non-Functional Metrics\n\nSince microservice has merged as a promising architectural style with advantages in maintainability, scalability, evolvability, etc., increasing companies choose to restructure their legacy monolithic software systems as the microservice architecture. However, it is quite a challenge to properly partitioning the systems into suitable parts as microservices. Most approaches perform microservices identification from a function-splitting perspective and with sufficient legacy software artifacts. That may be not realistic in industrial practices and possibly results in generating unexpected microservices. To address this, we proposed an automated microservice identification (AMI) approach that extracts microservices from the execution and performance logs without providing documentation, models or source codes, while taking both functional and non-functional metrics into considerations. Our work firstly collects logs from the executable legacy system. Then, controller objects (COs) are identified as the key objects to converge strongly related subordinate objects (SOs). Subsequently, the relation between each pair of CO and SO is evaluated by a relation matrix from both the functional and non-functional perspective. We ultimately cluster classes(objects) into the microservices by optimizing the multi-objective of high-cohesion-low-coupling and load balance. The usefulness of the proposed approach is illustrated by applying to a case study.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Design Method\": \"A method for designing software architectures, e.g., to obtain specific qualities or functions.\"}, \"Research Object\": [\"Architecture Design Method\"]}\n"}
{"prompt":"Data-Driven Software Architecture for Analyzing Confidentiality\n\nPreservation of confidentiality has become a crucial quality property of software systems that software vendors have to consider in each development phase. Especially, neglecting confidentiality constraints in the software architecture leads to severe issues in later phases that often are hard to correct. In contrast to the implementation phase, there is no support for systematically considering confidentiality in architectural design phases by means of data processing descriptions. To fill this gap, we introduce data flows in an architectural description language to enable simple definition of confidentiality constraints. Afterwards, we transform the software architecture specification to a logic program to find violated confidentiality constraints. In a case study-based evaluation, we apply the analysis to sixteen scenarios to show the accuracy of the approach.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Analysis Method\": \"A method for analyzing existing software architectures, e.g., to measure or evaluate specific qualities or functions.\", \"Architecture Description Language\": \"A formal or software language to create a description of a software architecture, i.e., \\\"any form of expression for use in architecture descriptions\\\" [ISO\/IEC 42010]. Papers propose or extend an existing architecture description language.\"}, \"Research Object\": [\"Architecture Description Language\", \"Architecture Analysis Method\"]}\n"}
{"prompt":"From a Monolith to a Microservices Architecture: An Approach Based on Transactional Contexts\n\nMicroservices have become the software architecture of choice for business applications. Initially originated at Netflix and Amazon, they result from the need to partition, both, software development teams and executing components, to, respectively, foster agile development and horizontal scalability. Currently, there is a large number of monolith applications that are being migrated to a microservices architecture. This article proposes the identification of business applications transactional contexts for the design of microservices. Therefore, the emphasis is to drive the aggregation of domain entities by the transactional contexts where they are executed, instead of by their domain structural inter-relationships. Additionally, we propose a complete workflow for the identification of microservices together with a set of tools that assist the developers on this process. The comparison of our approach with another software architecture tool and with an expert decomposition in two case studies revealed high precision values, which reflects that accurate service candidates are produced, while providing visualization perspectives facilitates the analysis of the impact of the decomposition on the application business logic.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architectural Aspects\": \"A method for identifying or specifying specific architectural aspects in existing implemented architectures, e.g., automatically identifying transactional contexts in an architecture. Note that if you analyze an architecture description containing these aspects, the analysis is a separate research object.\"}, \"Research Object\": [\"Architectural Aspects\"]}\n"}
{"prompt":"From Monolithic Architecture Style to Microservice one Based on a Semi-Automatic Approach\n\nDue to its tremendous advantages, microservice architectural style has become an essential element for the development of applications deployed on the cloud and for those adopting the DevOps practices. Nevertheless, while microservices can be used to develop new applications, there are monolithic ones, that are not well adapted neither to the cloud nor to DevOps. Migrating these applications towards microservices appears as a solution to adapt them to both. In this context, we propose an approach aiming to achieve this objective by focusing on the step of microservices identification. The proposed identification, in this paper, is based on an analysis of the relationships between source code elements, their relationships with the persistent data manipulated in this code and finally the knowledge, often partial, of the architect concerning the system to migrate. A function that measures the quality of a microservice based on its ability to provide consistent service and its interdependence with others microservice in the resulting architecture was defined. Moreover, the architect recommendations are used, when available, to guide the identification process. The conducted experiment shows the relevance of the obtained microservices by our approach.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Extraction\": \"Designing and realizing methods and algorithms to automatically extract architecture information from existing implementations.\"}, \"Research Object\": [\"Architecture Extraction\"]}\n"}
{"prompt":"Unlimited Rulebook: a Reference Architecture for Economy Mechanics in Digital Games\n\nIn game development, mechanics are one of the basis of the entertainment experience. However, the cost of implementing, improving, and refactoring economy mechanics is high because solutions cannot be easily reused across products. We argue that a reference architecture reduces this cost by providing knowledge reuse in addition to software reuse. To achieve that, we designed Unlimited Rulebook, a reference architecture for economy subsystems in games. It builds on established techniques such as Predicate Dispatching, the Entity-Component-System pattern, and the Adaptive Object-Model architectural style to facilitate the addition and modification of entity types and mechanics to the game while reducing the cost of changing existing code. We evaluated this cost reduction empirically via quasi-experiments with university students in two game programming courses.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Reference Architecture\": \"A description of an architecture (e.g., domain-specific or to solve recurring problems) that can be tailored to specific use cases.\"}, \"Research Object\": [\"Reference Architecture\"]}\n"}
{"prompt":"Dynamic {Updates} of {Virtual} {PLCs} {Deployed} as {Kubernetes} {Microservices}\n\nIndustrial control systems (e.g. programmable logic controllers, PLC or distributed control systems, DCS) cyclically execute control algorithms to automated production processes. Nowadays, for many applications their deployment is moving from dedicated embedded controllers into more flexible container environments, thus becoming \u201cVirtual PLCs\u201d. It is difficult to update such containerized Virtual PLCs during runtime by switching to a newer instance, which requires transferring internal state. Former research has only proposed dynamic update approaches for single embedded controllers, while other work introduced special Kubernetes (K8s) state replication approaches, which did not support cyclic real-time applications. We propose a dynamic update mechanism for Virtual PLCs deployed as K8s microservices. This approach is based on a purpose-built K8s Operator and allows control application updates without halting the production processes. Our experimental validation shows that the approach can support the internal state transfer of large industrial control applications (100.000 state variables) within only 15% of the available cycle slack time. Therefore, the approach creates vast opportunities for updating applications on-the-fly and migrating them between nodes in a cloud-native fashion.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Optimization Method\": \"A method to optimize existing architectures (implemented or designed) regarding specific qualities or properties.\"}, \"Research Object\": [\"Architecture Optimization Method\"]}\n"}
{"prompt":"Aspect-Oriented Modeling of Technology Heterogeneity in Microservice Architecture\n\nMicroservice Architecture (MSA) is a novel approach for the development and deployment of service-based software systems. MSA puts a strong emphasis on loose coupling and high cohesion of services. This increases service-specific independence, which is considered to result in a better scalability, adaptability, and quality of software architectures. Another perceived benefit of adopting MSA is technology heterogeneity. Microservice teams are free to employ the technologies they deem to be most appropriate for service implementation and operation. However, technology heterogeneity increases the number of technologies in a microservice architecture with the risk to introduce technical debt and steeper learning curves for team members. In this paper, we present an approach to streamline the usage of different technologies in MSA-based software systems. It employs Aspect-oriented Modeling to make technology decisions in microservice architectures explicit and enable reasoning about them. Therefore, a set of languages for model-driven microservice development is extended with means to define, modularize, and apply MSA technology aspects. The usage and characteristics of our approach are shown and discussed in the context of a case study from the mobility domain.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Design Method\": \"A method for designing software architectures, e.g., to obtain specific qualities or functions.\"}, \"Research Object\": [\"Architecture Design Method\"]}\n"}
{"prompt":"How {Software} {Architects} {Focus} {Their} {Attention}\n\nAs part of our software architecture research and practice we have found that a common difficulty for new architects is knowing where to focus their attention to maximise their effectiveness. This led us to wonder whether successful experienced architects have any common techniques or heuristics that they use to help them achieve this. In an earlier study where, having interviewed experienced architects, we found that in fact there were some common heuristics that they use, we created a simple model based on an analysis of their advice. In this paper we explain how we validated that model with a wider survey of experienced enterprise and software architects and, from the findings of that study, extended the model with an additional dimension. This resulted in our model having four primary guidelines, which are: focus on stakeholder needs and priorities, prioritise time according to risks, delegate as much as possible, and ensure team effectiveness.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Decision Making\": \"In software development and evolution, decision-making is an integral part. Various decisions are being made throughout the software development life cycle concerning processes, products, tools, methods, and techniques. From a decision-making perspective, all these questions are confronted by different objectives and constraints, a huge number of variables under dynamically changing requirements, processes, actors, stakeholders, tools, and techniques. This is combined with incomplete, fuzzy or inconsistent information about all the involved artifacts. [Ruhe2003]\"}, \"Research Object\": [\"Architecture Decision Making\"]}\n"}
{"prompt":"Architectural Assumptions and Their Management in Industry - An Exploratory Study\n\n\nAs an important type of architectural knowledge, architectural assumptions should be well managed in projects. However, little empirical research has been conducted regarding architectural assumptions and their management in software development. In this paper, we conducted an exploratory case study with twenty-four architects to analyze architectural assumptions and their management in industry. In this study, we confirmed certain findings from our previous survey on architectural assumptions (e.g., neither the term nor the concept of architectural assumption is commonly used in industry, and stakeholders may have different understandings of the architectural assumption concept). We also got five new findings: (1) architects frequently make architectural assumptions in their work; (2) the architectural assumption concept is subjective; (3) architectural assumptions are context-dependent and have a dynamic nature (e.g., turning out to be invalid or vice versa during their lifecycle); (4) there is a connection between architectural assumptions and certain types of software artifacts (e.g., requirements and design decisions); (5) twelve architectural assumptions management activities and four benefits of managing architectural assumptions were identified.\n\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architectural Assumptions\": \"Assumptions are the reasons for architectural decisions that are more or less arbitrarily taken on the fly because of personal experience, background, domain knowledge, the artifacts reused, and the like\"}, \"Research Object\": [\"Architectural Assumptions\"]}\n"}
{"prompt":"A Platform Architecture for Multi-Tenant Blockchain-Based Systems\n\nBlockchain has attracted a broad range of interests from start-ups, enterprises and governments to build next generation applications in a decentralized manner. Similar to cloud platforms, a single blockchain-based system may need to serve multiple tenants simultaneously. However, design of multi-tenant blockchain-based systems is challenging to architects in terms of data and performance isolation, as well as scalability. First, tenants must not be able to read other tenants' data and tenants with potentially higher workload should not affect read\/write performance of other tenants. Second, multi-tenant blockchain-based systems usually require both scalability for each individual tenant and scalability with number of tenants. Therefore, in this paper, we propose a scalable platform architecture for multi-tenant blockchain-based systems to ensure data integrity while maintaining data privacy and performance isolation. In the proposed architecture, each tenant has an individual permissioned blockchain to maintain their own data and smart contracts. All tenant chains are anchored into a main chain, in a way that minimizes cost and load overheads. The proposed architecture has been implemented in a proof-of-concept prototype with our industry partner, Laava ID Pty Ltd (Laava). We evaluate our proposal in a three-fold way: fulfilment of the identified requirements, qualitative comparison with design alternatives, and quantitative analysis. The evaluation results show that the proposed architecture can achieve data integrity, performance isolation, data privacy, configuration flexibility, availability, cost efficiency and scalability.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Reference Architecture\": \"A description of an architecture (e.g., domain-specific or to solve recurring problems) that can be tailored to specific use cases.\"}, \"Research Object\": [\"Reference Architecture\"]}\n"}
{"prompt":"Optimized {Dependency} {Weights} in {Source} {Code} {Clustering}\n\nSome methods use the dependencies between source code entities to perform clustering to, e.g., automatically map to an intended modular architecture or reconstruct the implemented software architecture. However, there are many different ways that source code entities can depend on each other in an object-oriented system, and it is not likely that all dependencies are equally useful. We investigate how well an optimized set of weights for 14 different types of dependencies perform when automatically mapping source code to modules using an established mapping technique. The optimized weights were found using genetic optimization. We compare the F1 score of precision and recall to uniform weights and weights computed by module relation ratio in eight open-source systems to evaluate performance. Our experiments show that optimized weights significantly outperform the others, especially in systems that seem not to have been designed using the low coupling, high cohesion principle. We also find that dependencies based on method calls are not useful for automatic mapping in any of the eight systems.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Analysis Method\": \"A method for analyzing existing software architectures, e.g., to measure or evaluate specific qualities or functions.\"}, \"Research Object\": [\"Architecture Analysis Method\"]}\n"}
{"prompt":"Preventing Erosion in Exception Handling Design Using Static-Architecture Conformance Checking\n\nException handling is a common error recovery technique employed to improve software robustness. However, studies have reported that exception handling is commonly neglected by developers and is the least understood and documented part of a software project. The lack of documentation and difficulty in understanding the exception handling design can lead developers to violate important design decisions, triggering an erosion process in the exception handling design. Architectural conformance checking provides means to control the architectural erosion by periodically checking if the actual architecture is consistent with the planned one. Nevertheless, available approaches do not provide a proper support for exception handling conformance checking. To fulfill this gap, we propose ArCatch: an architectural conformance checking solution to deal with the exception handling design erosion. ArCatch provides: (i) a declarative language for expressing design constraints regarding exception handling; and (ii) a design rule checker to automatically verify the exception handling conformance. To evaluate the usefulness and effectiveness of our approach, we conducted a case study, in which we evaluated an evolution scenario composed by 10 versions of an existing web-based Java system. Each version was checked against the same set of exception handling design rules. Based on the results and the feedback given by the system\u2019s architect, the ArCatch proved useful and effective in the identification of existing exception handling erosion problems and locating its causes in the source code.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Analysis Method\": \"A method for analyzing existing software architectures, e.g., to measure or evaluate specific qualities or functions.\"}, \"Research Object\": [\"Architecture Analysis Method\"]}\n"}
{"prompt":"On the Understandability of Semantic Constraints for Behavioral Software Architecture Compliance: {A} Controlled Experiment\n\nSoftware architecture compliance is concerned with the alignment of implementation with its desired architecture and detecting potential inconsistencies. The work presented in this paper is specifically concerned with behavioral architecture compliance. That is, the focus is on semantic alignment of implementation and architecture. In particular, this paper evaluates three representative approaches for describing semantic constraints in terms of their understandability, namely natural language descriptions as used in many architecture documentations today, a structured language based on specification patterns that abstract underlying temporal logic formulas, and a structured cause-effect language that is based on Complex Event Processing. We conducted a controlled experiment with 190 participants using a simple randomized design with one alternative per experimental unit. Overall all approaches support a high level of correct understanding, and the statistical inference suggests that all tested approaches are equally well suited for describing semantic constraints for behavioral architecture compliance in terms of understandability. In consequence this indicates that it is possible to benefit from the tested structured languages with underlying formal representations for automated verification without having to suffer from decreased understandability. Vice versa, the results suggest that the use of natural language can be a suitable way to document architecture semantics when reliable automated support for formal verification is of minor importance.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Description Language\": \"A formal or software language to create a description of a software architecture, i.e., \\\"any form of expression for use in architecture descriptions\\\" [ISO\/IEC 42010]. Papers propose or extend an existing architecture description language.\"}, \"Research Object\": [\"Architecture Description Language\"]}\n"}
{"prompt":"Integrating Statistical Response Time Models in Architectural Performance Models\n\nPerformance predictions enable software architects to optimize the performance of a software system early in the development cycle. Architectural performance models and statistical response time models are commonly used to derive these performance predictions. However, both methods have significant downsides: Statistical response time models can only predict scenarios for which training data is available, making the prediction of previously unseen system configurations infeasible. In contrast, the time required to simulate an architectural performance model increases exponentially with both system size and level of modeling detail, making the analysis of large, detailed models challenging. Existing approaches use statistical response time models in architectural performance models to avoid modeling subsystems that are difficult or time-consuming to model, yet they do not consider simulation time. In this paper, we propose to model software systems using classical queuing theory and statistical response time models in parallel. This approach allows users to tailor the model for each analysis run, based on the performed adaptations and the requested performance metrics. Our approach enables faster model solution compared to traditional performance models while retaining their ability to predict previously unseen scenarios. In our experiments we observed speedups of up to 94.8%, making the analysis of much larger and more detailed systems feasible.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Analysis Method\": \"A method for analyzing existing software architectures, e.g., to measure or evaluate specific qualities or functions.\"}, \"Research Object\": [\"Architecture Analysis Method\"]}\n"}
{"prompt":"Continuous Adaptation Management in Collective Intelligence Systems\n\nCollective Intelligence Systems (CIS), such as wikis and social networks, enable enhanced knowledge creation and sharing at organization and society levels. From our experience in R&D projects with industry partners and in-house CIS development, we learned that these platforms go through a complex evolution process. A particularly challenging aspect in this respect represents uncertainties that can appear at any time in the life-cycle of such systems. A prominent way to deal with uncertainties is adaptation, i.e., the ability to adjust or reconfigure the system in order to mitigate the impact of the uncertainties. However, there is currently a lack of consolidated design knowledge of CIS-specific adaptation and methods for managing it. To support software architects, we contribute an architecture viewpoint for continuous adaptation management in CIS, aligned with ISO\/IEC\/IEEE 42010. We evaluated the viewpoint in a case study with a group of eight experienced engineers. The results show that the viewpoint is well-structured, useful and applicable, and that its model kinds cover well the scope to handle different CIS-specific adaptation problems.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Analysis Method\": \"A method for analyzing existing software architectures, e.g., to measure or evaluate specific qualities or functions.\"}, \"Research Object\": [\"Architecture Analysis Method\"]}\n"}
{"prompt":"Updating {Service}-{Based} {Software} {Systems} in {Air}-{Gapped} {Environments}\n\nContemporary component-based systems often manifest themselves as service-based architectures, where a central activity is management of their software updates. However, stringent security constraints in mission-critical settings often impose compulsory network isolation among systems, also known as air-gap; a prevalent choice in different sectors including private, public or governmental organizations. This raises several issues involving updates, stemming from the fact that controlling the update procedure of a distributed service-based system centrally and remotely is precluded by network isolation policies. A dedicated software architecture is thus required, where key themes are dependability of the update process, interoperability with respect to the software supported and auditability regarding update actions previously performed. We adopt an architectural viewpoint and present a technical framework for updating service-based systems in air-gapped environments. We describe the particularities of the domain characterized by network isolation and provide suitable notations for service versions, whereupon satisfiability is leveraged for dependency resolution; those are situated within an overall architectural design. Finally, we evaluate the proposed framework over a realistic case study of an international organization, and assess the performance of the dependency resolution procedures for practical problem sizes.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Reference Architecture\": \"A description of an architecture (e.g., domain-specific or to solve recurring problems) that can be tailored to specific use cases.\"}, \"Research Object\": [\"Reference Architecture\"]}\n"}
{"prompt":"A Blockchain-Based Micro Economy Platform for Distributed Infrastructure Initiatives\n\nDistributed Infrastructure Initiatives (DIIs) are communities that collaboratively produce and consume infrastructure. To develop a healthy ecosystem, DIIs require an economic model that balances supply and demand, but there is currently a lack of tooling to support implementing these. In this research, we propose an architecture for a platform that enables DIIs to implement such models, focused around a digital currency based on blockchain technology. The currency is issued according to the amount participants contribute to the initiative, which is quantified based on operational metrics gathered from the infrastructure. Furthermore, the platform enables participants to deploy smart contracts which encode self-enforcing agreements about the infrastructure services they exchange. The architecture has been evaluated through a case study at The Things Network (TTN) a global distributed crowdsourced Internet of Things initiative. The case study revealed that the architecture is effective for the selected case at TTN. In addition, the results motivate future research lines to support scalability (i.e., to deploy the architecture on a larger scale) and security.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Reference Architecture\": \"A description of an architecture (e.g., domain-specific or to solve recurring problems) that can be tailored to specific use cases.\"}, \"Research Object\": [\"Reference Architecture\"]}\n"}
{"prompt":"{CAPS:} Architecture Description of Situational Aware Cyber Physical Systems\n\nThis paper proposes CAPS, an architecture-driven modeling framework for the development of Situational Aware Cyber-Physical Systems. Situational Awareness involves being aware of what ishappening in the surroundings, and using this information to decide and act. It has been recognized as a critical, yet often elusive, foundation for successful decision-making in complex systems. With the advent of cyber-physical systems (CPS), situational awareness is playing an increasingly important role especially in crowd and fleets management, infrastructure monitoring, and smart city applications. While specializing cyber physical systems, Situational Aware CPS requires the continuous monitoring of environmental conditions and events with respect to time and space. New architectural concerns arise, especially related to the sense, compute & communication paradigm, the use of domain-specific hardware components, and the cyber-physical space dimension. This work illustrates the CAPS modeling languages used to describe the software architecture, hardware configuration, and physical space views for a situational aware CPS.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Description Language\": \"A formal or software language to create a description of a software architecture, i.e., \\\"any form of expression for use in architecture descriptions\\\" [ISO\/IEC 42010]. Papers propose or extend an existing architecture description language.\"}, \"Research Object\": [\"Architecture Description Language\"]}\n"}
{"prompt":"Understanding Software Vulnerabilities Related to Architectural Security Tactics: An Empirical Investigation of Chromium, {PHP} and Thunderbird\n\nTo satisfy security requirements, software architects often adopt security tactics. These architectural tactics provide mechanisms for resisting, detecting, reacting to and recovering from attacks. Consequently, flaws in the implementation of security tactics or their deterioration during software evolution and maintenance can introduce severe vulnerabilities that could be exploited by attackers. However, we currently lack an in-depth understanding of the types and impact of vulnerabilities related to security tactics. Therefore, in this paper, we conduct a first-of-its-kind in-depth case study involving three large-scale open-source systems. We investigate the most common types of vulnerabilities associated with security tactics, how frequently they may occur over time, and how fixing them differs from fixing vulnerabilities that are not related to security tactics. Key findings are (i) most tactic-related vulnerabilities were related to the tactics \"Validate Inputs\" and \"Authorize Actors\", (ii) vulnerabilities related to tactics have a similar distribution over time and software releases as vulnerabilities that are not related to tactics, (iii) fixing tactic-related vulnerabilities is not necessarily more complex than fixing vulnerabilities that are not related to security tactics. This study highlights the importance of ensuring an appropriate implementation of security-related design decisions in code to avoid vulnerabilities rooted in the architecture.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Pattern\": \"An architectural pattern is a general, reusable solution to a commonly occurring problem in software architecture within a given context. Patterns with negative effects on the product, i.e., anti-patterns, are also included here.\"}, \"Research Object\": [\"Architecture Pattern\"]}\n"}
{"prompt":"{EASIER:} An Evolutionary Approach for Multi-objective Software ArchItecturE Refactoring\n\nMulti-objective optimization has demonstrated, in the last few years, to be an effective paradigm to tackle different architectural problems, such as service selection, composition and deployment. In particular, multi-objective approaches for searching architectural configurations that optimize quality properties (such as performance, reliability and cost) have been introduced in the last decade. However, a relevant amount of complexity is introduced in this context when performance are considered, often due to expensive iterative generation of performance models and interpretation of results. In this paper we introduce EASIER (Evolutionary Approach for multi-objective Software archItecturE Refactoring), that is an approach for optimizing architecture refactoring based on performance and on the intensity of changes. We focus on the actionable aspects of architectural optimization, instead of merely searching over a set of alternatives. We also start to investigate on the potential influence of performance antipatterns on such process. We have implemented our approach on AEmilia ADL, so to carry out performance analysis and architecture refactoring within the same environment. We demonstrate the effectiveness and applicability of our approach through its experimentation on a case study.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Optimization Method\": \"A method to optimize existing architectures (implemented or designed) regarding specific qualities or properties.\"}, \"Research Object\": [\"Architecture Optimization Method\"]}\n"}
{"prompt":"Enabling Consistency between Software Artefacts for Software Adaption and Evolution\n\nShort development times of software became crucial to stay competitive. However, the quality should not suffer from the faster development processes, which is why increasingly more automation is gaining ground in this context. If models are involved in the development process and used for performance prediction, there are delays due to emerging inconsistencies between different software artifacts. The elimination of these inconsistencies is a time consuming, complex and error prone activity. Currently, there are already approaches for automated consistency preservation of software artifacts. Nevertheless, the limited scope in terms of supported change scenarios is a significant disadvantage.Therefore, we present a comprehensive approach for the maintenance of consistency between the system design and adaptive as well as evolutionary changes. In comparison to existing approaches, the consistency preservation has been significantly extended in our approach to cover a multitude of changes resulting from adaptation and evolution. Ultimately, several validation steps were integrated into the approach, enabling continuous assessment regarding the quality of the consistency preservation. In a case study based evaluation, we measured the accuracy of the updated models and associated performance predictions.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Evolution\": \"The process of maintaining and adapting existing software architecture to meet requirements and environmental changes [Imran et al., 2016]. This includes papers that investigate the evolution of specific architectures.\"}, \"Research Object\": [\"Architecture Evolution\"]}\n"}
{"prompt":"QoS-Based Formation of Software Architectures in the Internet of Things\n\nArchitecting Internet of Things (IoT) systems is very challenging due to the heterogeneity of connected objects and devices, and their dynamic variabilities such as mobility and availability. The complexity of this scenario is exacerbated when considering Quality-of-Service (QoS) constraints. Indeed, reasoning about multiple quality attributes, e.g., power consumption and response time, makes the management of IoT systems even more difficult since it is necessary to jointly evaluate multiple system characteristics. The focus of this paper is on modelling and analysing QoS-related characteristics in IoT architectures. To this end, we leverage on the concept of Emergent Architectures (EAs), i.e., a set of things temporarily cooperating to achieve a given goal, by intertwining EAs with QoS-related constraints. Our approach provides the automated formation of the most suitable EAs by means of a QoS-based optimisation problem. We developed an IoT case study and experimental results demonstrate the effectiveness of the proposed approach.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Design Method\": \"A method for designing software architectures, e.g., to obtain specific qualities or functions.\"}, \"Research Object\": [\"Architecture Design Method\"]}\n"}
{"prompt":"A Quantitative Approach for the Assessment of Microservice Architecture Deployment Alternatives by Automated Performance Testing\n\nMicroservices have emerged as an architectural style for developing distributed applications. Assessing the performance of architectural deployment alternatives is challenging and must be aligned with the system usage in the production environment. In this paper, we introduce an approach for using operational profiles to generate load tests to automatically assess scalability pass\/fail criteria of several microservices deployment alternatives. We have evaluated our approach with different architecture deployment alternatives using extensive lab studies in a large bare metal host environment and a virtualized environment. The data presented in this paper supports the need to carefully evaluate the impact of increasing the level of computing resources on performance. Specifically, for the case study presented in this paper, we observed that the evaluated performance metric is a non-increasing function of the number of CPU resources for one of the environments under study.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Analysis Method\": \"A method for analyzing existing software architectures, e.g., to measure or evaluate specific qualities or functions.\"}, \"Research Object\": [\"Architecture Analysis Method\"]}\n"}
{"prompt":"On Interfaces to Support Agile Architecting in Automotive: An Exploratory Case Study\n\nPractitioners struggle with creating and evolving an architecture when developing complex and safety-critical systems in large-scale agile contexts. A key issue is the trade-off between upfront planning and flexibility to embrace change. In particular, the coordination of interfaces is an important challenge, as interfaces determine and regulate the exchange of information between components, subsystems, and systems, which are often developed by multiple teams. In a fast-changing environment, boundary objects between teams can provide the sufficient stability to align software or systems, while maintaining a sufficient degree of autonomy. However, a better understanding of interfaces as boundary objects is needed to give practical guidance. This paper presents an exploratory case study with an automotive OEM to identify characteristics of different interfaces, from non-critical interfaces that can be changed frequently and quickly, to those that are critical and require more stability and a rigorous change process. We identify what dimensions impact how interfaces are changed, what categories of interfaces exist along these dimensions, and how categories of interfaces change over time. We conclude with suggestions for practices to manage the different categories of interfaces in large-scale agile development.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Evolution\": \"The process of maintaining and adapting existing software architecture to meet requirements and environmental changes [Imran et al., 2016]. This includes papers that investigate the evolution of specific architectures.\"}, \"Research Object\": [\"Architecture Evolution\"]}\n"}
{"prompt":"Architectural Security Weaknesses in Industrial Control Systems {(ICS)} an Empirical Study Based on Disclosed Software Vulnerabilities\n\nIndustrial control systems (ICS) are systems used in critical infrastructures for supervisory control, data acquisition, and industrial automation. ICS systems have complex, component-based architectures with many different hardware, software, and human factors interacting in real time. Despite the importance of security concerns in industrial control systems, there has not been a comprehensive study that examined common security architectural weaknesses in this domain. Therefore, this paper presents the first in-depth analysis of 988 vulnerability advisory reports for Industrial Control Systems developed by 277 vendors. We performed a detailed analysis of the vulnerability reports to measure which components of ICS have been affected the most by known vulnerabilities, which security tactics were affected most often in ICS and what are the common architectural security weaknesses in these systems. Our key findings were: (1) Human-Machine Interfaces, SCADA configurations, and PLCs were the most affected components, (2) 62.86% of vulnerability disclosures in ICS had an architectural root cause, (3) the most common architectural weaknesses were \u201cImproper Input Validation\u201d, followed by \u201cIm-proper Neutralization of Input During Web Page Generation\u201d and \u201cImproper Authentication\u201d, and (4) most tactic-related vulnerabilities were related to the tactics \u201cValidate Inputs\u201d, \u201cAuthenticate Actors\u201d and \u201cAuthorize Actors\u201d.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architectural Aspects\": \"A method for identifying or specifying specific architectural aspects in existing implemented architectures, e.g., automatically identifying transactional contexts in an architecture. Note that if you analyze an architecture description containing these aspects, the analysis is a separate research object.\"}, \"Research Object\": [\"Architectural Aspects\"]}\n"}
{"prompt":"On Service-Orientation for Automotive Software\n\nBackground: During the last decades, the functional power and complexity of automotive E\/E architectures grew radically and is going to grow further in the future. For highly and fully automated driving, functions with the highest safety integrity level need to be realized, requiring new development methodologies and a new level of formal rigor. Aim: We investigate to what extent SOA concepts are applicable for safety-critical embedded automotive software systems and whether this concept is appealing to E\/E architects. Method: We conducted a survey research by interviewing system architects at our industrial partner, then we applied the grounded theory method in order to derive a theory and a set of requirements for an automotive SOA approach. Additionally, we illustrate the approach using a function needed in a highly automated driving scenario. Results: We present a formal service model and an automotive SOA framework. Both aspects, i.e., architecture structuring and formal service description resulted from the analyzed interview data. Limitation: This approach has not been evaluated extensively, yet. Conclusion: Our first results suggest that SOA concepts are indeed successfully applicable in (continuous) automotive software engineering and are a means to cope with complexity and safety requirements.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Pattern\": \"An architectural pattern is a general, reusable solution to a commonly occurring problem in software architecture within a given context. Patterns with negative effects on the product, i.e., anti-patterns, are also included here.\"}, \"Research Object\": [\"Architecture Pattern\"]}\n"}
{"prompt":"Determination and Enforcement of Least-Privilege Architecture in Android\n\nModern mobile platforms rely on a permission model to guard the system's resources and apps. In Android, since the permissions are granted at the granularity of apps, and all components belonging to an app inherit those permissions, an app's components are typically over-privileged, i.e., components are granted more privileges than they need to complete their tasks. Systematic violation of least-privilege principle in Android has shown to be the root cause of many security vulnerabilities. To mitigate this issue, we have developed DELDROID, an automated system for determination of least privilege architecture in Android and its enforcement at runtime. A key contribution of our approach is the ability to limit the privileges granted to apps without the need to modify them. DELDROID utilizes static program analysis techniques to extract the exact privileges each component needs for providing its functionality. A Multiple-Domain Matrix representation of the system's architecture is then used to automatically analyze the security posture of the system and derive its least-privilege architecture. Our experiments on hundreds of real world apps corroborate DELDROID's ability in effectively establishing the least-privilege architecture and its benefits in alleviating the security threats.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Extraction\": \"Designing and realizing methods and algorithms to automatically extract architecture information from existing implementations.\"}, \"Research Object\": [\"Architecture Extraction\"]}\n"}
{"prompt":"Component-Based Refinement and Verification of Information-Flow Security Policies for Cyber-Physical Microservice Architectures\n\nSince cyber-physical systems are inherently vulnerable to information leaks, software architects need to reason about security policies to define desired and undesired information flow through a system. The microservice architectural style requires the architects to refine a macro-level security policy into micro-level policies for individual microservices. However, when policies are refined in an ill-formed way, information leaks can emerge on composition of microservices. Related approaches to prevent such leaks do not take into account characteristics of cyber-physical systems like real-time behavior or message passing communication. In this paper, we enable the refinement and verification of information-flow security policies for cyber-physical microservice architectures. We provide architects with a set of well-formedness rules for refining a macro-level policy in a way that enforces its security restrictions. Based on the resulting micro-level policies, we present a verification technique to check if the real-time message passing of microservices is secure. In combination, our contributions prevent information leaks from emerging on composition. We evaluate the accuracy of our approach using an extension of the CoCoME case study.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Analysis Method\": \"A method for analyzing existing software architectures, e.g., to measure or evaluate specific qualities or functions.\"}, \"Research Object\": [\"Architecture Analysis Method\"]}\n"}
{"prompt":"Decision Models for Microservices: Design Areas, Stakeholders, Use Cases, and Requirements\n\nIntroducing a microservice architecture is a complex task, requiring many design decisions regarding system architecture, organizational structure, and system infrastructure. Decision models have been successfully used in other domains for design space exploration, decision making and decision documentation. In this paper, we investigate the use of decision models for microservice architecture. As a first step, we identified areas of microservice design and created decision models for some of the identified areas. We then used the created models as part of a technical action research (TAR) process with partner companies to identify important stakeholders and use cases for decision models in this context, as well as to identify requirements on decision model elements and presentation. Results indicate that practitioners perceive decision models for microservices to be useful. Challenges include the large number of interlinked knowledge areas, the need for context-specific adaptations, and the need for processes to manage the decision space over time.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Decision Making\": \"In software development and evolution, decision-making is an integral part. Various decisions are being made throughout the software development life cycle concerning processes, products, tools, methods, and techniques. From a decision-making perspective, all these questions are confronted by different objectives and constraints, a huge number of variables under dynamically changing requirements, processes, actors, stakeholders, tools, and techniques. This is combined with incomplete, fuzzy or inconsistent information about all the involved artifacts. [Ruhe2003]\"}, \"Research Object\": [\"Architecture Decision Making\"]}\n"}
{"prompt":"Model-based Performance Analysis for Architecting Cyber-Physical Dynamic Spaces\n\nArchitecting Cyber-Physical Systems is not trivial since their intrinsic nature of mixing software and hardware components poses several challenges, especially when the physical space is subject to dynamic changes, e.g., paths of robots suddenly not feasible due to objects occupying transit areas or doors being closed with a high probability. This paper provides a quantitative evaluation of different architectural patterns that can be used for cyber-physical systems to understand which patterns are more suitable under some peculiar characteristics of dynamic spaces, e.g., frequency of obstacles in paths. We use stochastic performance models to evaluate architectural patterns, and we specify the dynamic aspects of the physical space as probability values. This way, we aim to support software architects with quantitative results indicating how different design patterns affect some metrics of interest, e.g., the system response time. Experiments show that there is no unique architectural pattern suitable to cope with all the dynamic characteristics of physical spaces. Each architecture differently contributes when varying the physical space, and it is indeed beneficial to switch among multiple patterns for an optimal solution.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Analysis Method\": \"A method for analyzing existing software architectures, e.g., to measure or evaluate specific qualities or functions.\", \"Architecture Pattern\": \"An architectural pattern is a general, reusable solution to a commonly occurring problem in software architecture within a given context. Patterns with negative effects on the product, i.e., anti-patterns, are also included here.\"}, \"Research Object\": [\"Architecture Analysis Method\", \"Architecture Pattern\"]}\n"}
{"prompt":"How Developers Discuss Architecture Smells? An Exploratory Study on Stack Overflow\n\nArchitecture Smells (ASs) are design decisions that can have significant negative effects on a system's quality attributes such as reusability and testability. ASs are focused on higher level of software systems than code smells, which are implementation-level constructs. ASs can have much wider impact on a system than code smells. However, ASs usually receive less attention than code smells in both research and practice. We have conducted an exploratory study of developers' conception of ASs by analyzing related discussions in Stack Overflow. We used 14 ASs related terms to search the relevant posts in Stack Overflow and extracted 207 posts. We used Grounded Theory method for analyzing the extracted posts about developers' description of ASs, causes of ASs, approaches and tools for detecting and refactoring ASs, quality attributes affected by ASs, and difficulties in detecting and refactoring ASs. Our findings show that: (1) developers often describe ASs with some general terms; (2) ASs are mainly caused by violating architecture patterns, design principles, or misusing architecture antipatterns; (3) there is a lack of dedicated tools for detecting and refactoring ASs; (4) developers mainly concern about the maintainability and performance of systems affected by ASs; and (5) the inability to quantify the cost and benefit as well as the lack of approaches and tools makes detecting and refactoring ASs difficult.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Pattern\": \"An architectural pattern is a general, reusable solution to a commonly occurring problem in software architecture within a given context. Patterns with negative effects on the product, i.e., anti-patterns, are also included here.\"}, \"Research Object\": [\"Architecture Pattern\"]}\n"}
{"prompt":"Continuous Analysis of Collaborative Design\n\nIn collaborative design, architects' individual design decisions may conflict and, when joined, may violate system consistency rules or non-functional requirements. These design conflicts can hinder collaboration and result in wasted effort. Proactive detection of code-level conflicts has been shown to improve collaborative productivity, however, the computational resource requirements for proactively computing design conflicts have hindered its applicability in practice. Our survey and interviews of 50 architects from six large software companies find that 60% of their projects involve collaborative design, that architects consider integration costly, and that design conflicts are frequent and lead to lost work. To aid collaborative design, we re-engineer FLAME, our prior design conflict detection technique, to use cloud resources and a novel prioritization algorithm that, together, achieve efficient and nonintrusive conflict detection, and guarantee a bound on the time before a conflict is discovered. Two controlled experiments with 90 students trained in software architecture in a professional graduate program, demonstrate that architects using FLAME design more efficiently, produce higher-quality designs, repair conflicts faster, and prefer using FLAME. An empirical performance evaluation demonstrates FLAME's scalability and verifies its time-bound guarantees.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Design Method\": \"A method for designing software architectures, e.g., to obtain specific qualities or functions.\"}, \"Research Object\": [\"Architecture Design Method\"]}\n"}
{"prompt":"An {Exploratory} {Study} on {Architectural} {Knowledge} in {Issue} {Tracking} {Systems}\n\nSoftware developers use issue trackers (e.g. Jira) to manage defects, bugs, tasks, change requests, etc. In this paper we explore (a) how architectural knowledge concepts (e.g. architectural component behavior, contextual constraints) are textually represented in issues (e.g. as adjectives), (b) which architectural knowledge concepts commonly occur in issues, and (c) which architectural knowledge concepts appear together. We analyzed issues in the Jira issue trackers of three large Apache projects. To identify \u201carchitecturally relevant\u201d issues, we linked issues to architecturally relevant source code changes in the studied systems. We then developed a code book by manually labeling a subset of issues. After reaching conceptual saturation, we coded remaining issues. Our findings support empirically-grounded search tools to identify architectural knowledge concepts in issues for future reuse.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Description\": \"An Architecture Description (AD) is a work product used to express the Architecture of some System Of Interest. An AD describes one possible Architecture for a System Of Interest. An AD may take the form of a document, a set of models, a model repository, or some other form [ISO\/IEC 42010]. Papers use existing architecture description languages to describe architectures.\"}, \"Research Object\": [\"Architecture Description\"]}\n"}
{"prompt":"Formal Software Architectural Migration Towards Emerging Architectural Styles\n\nSoftware systems are evolved over time to enhance various qualities of the software system by adopting new technologies and principles. The architecture design is usually required to be migrated from one architectural style to another to support this adoption, while the key functionalities still need to be preserved. This paper presents a formal approach that supports architectural migration. Our approach automates refactoring the architectural design to support the exploitation of emerging technologies such as microservices and blockchain. With our approach, the refactored architectural design can be verified to ensure that the essential functional requirements are still preserved, and the design has complied with the behavioural constraints of new architectural styles. We have evaluated the accuracy and performance of our approach. The results prove that it performs reasonably well.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Description Language\": \"A formal or software language to create a description of a software architecture, i.e., \\\"any form of expression for use in architecture descriptions\\\" [ISO\/IEC 42010]. Papers propose or extend an existing architecture description language.\"}, \"Research Object\": [\"Architecture Description Language\"]}\n"}
{"prompt":"Accurate Analysis of Quality Properties of Software with Observation-Based Markov Chain Refinement\n\nWe introduce a tool-supported method for the automated refinement of continuous-time Markov chains (CTMCs) used to assess quality properties of component-based software. Existing research focuses on improving the efficiency of CTMC analysis and on identifying new applications for this analysis. As such, ensuring that the analysis is accurate by using CTMCs that closely model the behaviour of the analysed software has received relatively little attention. Our new method addresses this gap by refining the high-level CTMC model of a component-based software system based on observations of the execution times of its components. Our refinement method reduced analysis errors by 77-90.3% for a service-based system implemented using six public web services from three different providers, improving the accuracy of the analysis and significantly reducing the risk of invalid software engineering decisions.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Analysis Method\": \"A method for analyzing existing software architectures, e.g., to measure or evaluate specific qualities or functions.\"}, \"Research Object\": [\"Architecture Analysis Method\"]}\n"}
{"prompt":"A Comparison of {MQTT} Brokers for Distributed IoT Edge Computing\n\nMany enterprise IoT application scenarios, such as connected cars, smart cities, and cloud-connected industrial plants require distributed MQTT brokers to achieve high scalability and availability. With a market of over 20 MQTT brokers, it is hard for software architects to make a good selection. Existing MQTT comparisons often include only non-distributed brokers, focus exclusively on performance, or are difficult to generalize. We compared three distributed MQTT brokers for performance, scalability, resilience, security, extensibility, and usability in an enterprise IoT scenario deployed to an edge gateway cluster. We found that EMQX provided the best performance (28K\u00a0msg\/s), while only HiveMQ showed no message loss in our test scenario. VerneMQ offers similar features as the other brokers but is fully available as open source. The paper includes decision guidance for software architects, listing six major decision points regarding MQTT brokers.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architectural Aspects\": \"A method for identifying or specifying specific architectural aspects in existing implemented architectures, e.g., automatically identifying transactional contexts in an architecture. Note that if you analyze an architecture description containing these aspects, the analysis is a separate research object.\"}, \"Research Object\": [\"Architectural Aspects\"]}\n"}
{"prompt":"A {Machine} {Learning} {Approach} to {Service} {Discovery} for {Microservice} {Architectures}\n\nService discovery mechanisms have continuously evolved during the last years to support the effective and efficient service composition in large-scale microservice applications. Still, the dynamic nature of services (and of their contexts) are being rarely taken into account for maximizing the desired quality of service. This paper proposes using machine learning techniques, as part of the service discovery process, to select microservice instances in a given context, maximize QoS, and take into account the continuous changes in the execution environment. Both deep neural networks and reinforcement learning techniques are used. Experimental results show how the proposed approach outperforms traditional service discovery mechanisms.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Optimization Method\": \"A method to optimize existing architectures (implemented or designed) regarding specific qualities or properties.\"}, \"Research Object\": [\"Architecture Optimization Method\"]}\n"}
{"prompt":"A Four-Layer Architecture Pattern for Constructing and Managing Digital Twins\n\nThe promise of a digital twin is to make asset lifecycle information accessible by providing a single access point to the information. Thereby, it reduces the required time and effort and enables new data-intensive use cases. This paper provides an abstract four-layer architecture pattern to construct digital twins and to incorporate information from various kinds of sources. The pattern is designed to be flexibly extensible with new information sources and can flexibly support new kinds of proprietary or standard information. We discuss various alternatives to implement the pattern and provide an example realization based on microservices and OPC UA.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Pattern\": \"An architectural pattern is a general, reusable solution to a commonly occurring problem in software architecture within a given context. Patterns with negative effects on the product, i.e., anti-patterns, are also included here.\"}, \"Research Object\": [\"Architecture Pattern\"]}\n"}
{"prompt":"ArCode: Facilitating the Use of Application Frameworks to Implement Tactics and Patterns\n\nSoftware designers and developers are increasingly relying on application frameworks as first-class design concepts. They instantiate the services that frameworks provide to implement various architectural tactics and patterns. One of the challenges in employing frameworks for such tasks is the difficulty of learning and correctly using the APIs of the frameworks. This paper introduces a learning-based approach called ARCODE to help novice programmers correctly use frameworks\u2019 APIs to implement architectural tactics and patterns. ARCODE has several novel components: a graph-based approach for learning specification of a framework from a limited number of training software, a program analysis algorithm to eliminate erroneous training data, and a recommender module to help programmers use APIs correctly and identify API misuses in their program. We evaluated our technique across two popular frameworks: JAAS security framework used for authentication and authorization tactic and Java RMI framework used to enable remote method invocation between client and server and other object oriented patterns. Our results demonstrate (i) the feasibility of using ARCODE to learn the specification of a framework; (ii) ARCODE generates accurate recommendations for finding the next API call to implement an architectural tactic\/pattern based on the context of the programmer\u2019s code; (iii) it accurately detects API misuses in the code that implements a tactic\/pattern and provides fix recommendations. We also demonstrate that ArCode outperforms two famous techniques, MAPO and GrouMiner, on API recommendation and misuse detection tasks.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architectural Aspects\": \"A method for identifying or specifying specific architectural aspects in existing implemented architectures, e.g., automatically identifying transactional contexts in an architecture. Note that if you analyze an architecture description containing these aspects, the analysis is a separate research object.\", \"Architecture Analysis Method\": \"A method for analyzing existing software architectures, e.g., to measure or evaluate specific qualities or functions.\"}, \"Research Object\": [\"Architectural Aspects\", \"Architecture Analysis Method\"]}\n"}
{"prompt":"A Goal-Driven Approach for Deploying Self-Adaptive IoT Systems\n\nEngineering Internet of Things (IoT) systems is a challenging task partly due to the dynamicity and uncertainty of the environment including the involvement of the human in the loop. Users should be able to achieve their goals seamlessly in different environments, and IoT systems should be able to cope with dynamic changes. Several approaches have been proposed to enable the automated formation, enactment, and self-adaptation of goal-driven IoT systems. However, they do not address deployment issues. In this paper, we propose a goal-driven approach for deploying self-adaptive IoT systems in the Edge-Cloud continuum. Our approach supports the systems to cope with the dynamicity and uncertainty of the environment including changes in their deployment topologies, i.e., the deployment nodes and their interconnections. We describe the architecture and processes of the approach and the simulations that we conducted to validate its feasibility. The results of the simulations show that the approach scales well when generating and adapting the deployment topologies of goal-driven IoT systems in smart homes and smart buildings.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Design Method\": \"A method for designing software architectures, e.g., to obtain specific qualities or functions.\"}, \"Research Object\": [\"Architecture Design Method\"]}\n"}
{"prompt":"Assessing Architecture Conformance to Coupling-Related Patterns and Practices in Microservices\n\nMicroservices are the go-to architectural style for building applications that are polyglot, support high scalability, independent development and deployment, and are rapidly adaptable to changes. Among the core tenets for a successful microservice architecture is high independence of the individual microservices, i.e. loose coupling. A number of patterns and best practices are well-established in the literature, but most actual microservice-based systems do not, as a whole or in part, conform to them. Assessing this conformance manually is not realistically possible for large-scale systems. This study aims to provide the foundations for an automated approach for assessing conformance to coupling-related patterns and practices specific for microservice architectures. We propose a model-based assessment based on generic, technology-independent metrics, connected to typical design decisions encountered in microservice architectures. We demonstrate and assess the validity and appropriateness of these metrics by performing an assessment of the conformance of real-world systems to patterns through statistical methods.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Analysis Method\": \"A method for analyzing existing software architectures, e.g., to measure or evaluate specific qualities or functions.\"}, \"Research Object\": [\"Architecture Analysis Method\"]}\n"}
{"prompt":"A {Runtime} {Safety} {Enforcement} {Approach} by {Monitoring} and {Adaptation}\n\nThe use of models and formal analysis techniques at runtime is fundamental to address safety assurance during the system operational stage, when all relevant uncertainties and unknowns can be resolved. This paper presents a novel approach to runtime safety enforcement of software systems based on the MAPE-K control loop architecture for system monitoring and control, and on the Abstract State Machine as runtime model representing the enforcement strategy aimed at preserving or eventually restoring safety. The enforcer software is designed as an autonomic manager that wraps around the software system to monitor and manage unsafe system changes using probing and effecting interfaces provided by the system, so realising grey-box safety enforcement. The proposed approach is supported by a component framework that is here illustrated by means of a case study in the health-care domain.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Design Method\": \"A method for designing software architectures, e.g., to obtain specific qualities or functions.\"}, \"Research Object\": [\"Architecture Design Method\"]}\n"}
{"prompt":"Continuous {API} Evolution in Heterogenous Enterprise Software Systems\n\nThe ability to independently deploy parts of a software system is one of the cornerstones of modern software development, and allows for these parts to evolve independently and at different speeds.A major challenge of such independent deployment, however, is to ensure that despite their individual evolution, the interfaces between interacting parts remain compatible. This is especially important for enterprise software systems, which are often highly integrated and based on heterogenous IT infrastructures.Although several approaches for interface evolution have been proposed, many of these rely on the developer to adhere to certain rules, but provide little guidance for doing so. In this paper, we present an approach for interface evolution that is easy to use for developers, and also addresses typical challenges of heterogenous enterprise software, especially legacy system integration.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Evolution\": \"The process of maintaining and adapting existing software architecture to meet requirements and environmental changes [Imran et al., 2016]. This includes papers that investigate the evolution of specific architectures.\"}, \"Research Object\": [\"Architecture Evolution\"]}\n"}
{"prompt":"Quantitative Verification-Aided Machine Learning: {A} Tandem Approach for Architecting Self-Adaptive IoT Systems\n\nArchitecting IoT systems able to guarantee Quality of Service (QoS) levels can be a challenging task due to the inherent uncertainties (induced by changes in e.g., energy availability, network traffic) that they are subject to. Existing work has shown that machine learning (ML) techniques can be effectively used at run time for selecting self-adaptation patterns that can help maintain adequate QoS levels. However, this class of approach suffers from learning bias, which induces accuracy problems that might lead to sub-optimal (or even unfeasible) adaptations in some situations. To overcome this limitation, we propose an approach for proactive self-adaptation which combines ML and formal quantitative verification (probabilistic model checking). In our approach, ML is tasked with selecting the best adaptation pattern for a given scenario, and quantitative verification checks the feasibility of the adaptation decision, preventing the execution of unfeasible adaptations and providing feedback to the ML engine which helps to achieve faster convergence towards optimal decisions. The results of our evaluation show that our approach is able to produce better decisions than ML and quantitative verification used in isolation.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Optimization Method\": \"A method to optimize existing architectures (implemented or designed) regarding specific qualities or properties.\"}, \"Research Object\": [\"Architecture Optimization Method\"]}\n"}
{"prompt":"Continuous Architecture: Towards the Goldilocks Zone and Away from Vicious Circles\n\nThis paper identifies three improvement areas related to system design and architecture, where an organization can change to better support continuous integration and continuous delivery: \u201cThe product's architecture\u201d, \u201cWays to work with system design and architecture\u201d, and \u201cThe role of the architect\u201d. The three improvement areas are based on a literature review, two series of interviews and a cross-company workshop with three case-study companies. Furthermore, the paper proposes three actionable strategies corresponding to the three identified improvement areas: \u201cSystems with a modular and loosely coupled architecture\u201d, \u201cA balanced approach where system design and architecture is focused on the system's most important characteristics\u201d, and \u201cArchitects shifting perspective from control to facilitation\u201d.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Decision Making\": \"In software development and evolution, decision-making is an integral part. Various decisions are being made throughout the software development life cycle concerning processes, products, tools, methods, and techniques. From a decision-making perspective, all these questions are confronted by different objectives and constraints, a huge number of variables under dynamically changing requirements, processes, actors, stakeholders, tools, and techniques. This is combined with incomplete, fuzzy or inconsistent information about all the involved artifacts. [Ruhe2003]\"}, \"Research Object\": [\"Architecture Decision Making\"]}\n"}
{"prompt":"Designing Robust Software Systems through Parametric Markov Chain Synthesis\n\nWe present a method for the synthesis of software system designs that satisfy strict quality requirements, are Pareto-optimal with respect to a set of quality optimisation criteria, and are robust to variations in the system parameters. To this end, we model the design space of the system under development as a parametric continuous-time Markov chain (pCTMC) with discrete and continuous parameters that correspond to alternative system architectures and to the ranges of possible values for configuration parameters, respectively. Given this pCTMC and required tolerance levels for the configuration parameters, our method produces a sensitivity-aware Pareto-optimal set of designs, which allows the modeller to inspect the ranges of quality attributes induced by these tolerances, thus enabling the effective selection of robust designs. Through application to two systems from different domains, we demonstrate the ability of our method to synthesise robust designs with a wide spectrum of useful tradeoffs between quality attributes and sensitivity.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Design Method\": \"A method for designing software architectures, e.g., to obtain specific qualities or functions.\"}, \"Research Object\": [\"Architecture Design Method\"]}\n"}
{"prompt":"Architectural Technical Debt: {A} Grounded Theory\n\nArchitectural technical debt in a software-intensive system is driven by design decisions about its structure, frameworks, technologies, languages, etc. Unlike code-level technical debt, which can be readily detected by static analysers, and can often be refactored with minimal efforts, architectural debt is hard to detect, and its remediation is wide-ranging, daunting, and often avoided. The objective of this study is to develop a better understanding of how software development organisations conceptualize their architectural debt, and how they deal with it, if at all. We used a grounded theory method, eliciting qualitative data from software architects and senior technical staff from a wide range of software development organizations. The result of the study, i.e., the theory emerging from the collected data, constitutes an encompassing conceptual theory of architectural debt, identifying and relating concepts such as symptoms, causes, consequences, and management strategies. By grounding the findings in empirical data, the theory provides researchers and practitioners with evidence of which crucial factors of architectural technical debt are experienced in industrial\u00a0contexts.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Technical Debt\": \"In software-intensive systems, technical debt consists of design or implementation constructs that are expedient in the short term, but set up a technical context that can make a future change more costly or impossible. Technical debt is a contingent liability whose impact is limited to internal system qualities, primarily maintainability and evolvability.\"}, \"Research Object\": [\"Technical Debt\"]}\n"}
{"prompt":"Semi-automatic Feedback for Improving Architecture Conformance to Microservice Patterns and Practices\n\nMicroservices are one of the most recommended architectural styles for distributed applications that support independent development and deployment, enable rapid release, and are highly scalable and polyglot. Many well-established patterns and best practices have been documented in the literature. As there are many such guidances, they have numerous interdependencies, and system designs must adhere to many other architecture constraints, too, implementations do not always conform to those guidances. In complex or large systems, it can be hard and tedious to spot violations. Our work aims to offer automated support for architecting during the continuous evolution of microservice-based systems. More specifically we aim to provide the foundations for an automated approach for architecture reconstruction, assessing conformance to patterns and practices specific for microservice architectures, and detect possible violations. Based on this, we provide actionable options to architects for improving architecture conformance as part of a continuous feedback loop. That is, our goal is to support architecting in the context of continuous delivery practices, where architecture violations are continuously analyzed and fix options are continuously suggested.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Analysis Method\": \"A method for analyzing existing software architectures, e.g., to measure or evaluate specific qualities or functions.\", \"Architecture Optimization Method\": \"A method to optimize existing architectures (implemented or designed) regarding specific qualities or properties.\"}, \"Research Object\": [\"Architecture Analysis Method\", \"Architecture Optimization Method\"]}\n"}
{"prompt":"The Evolution of Technical Debt in the Apache Ecosystem\n\nSoftware systems must evolve over time or become increasingly irrelevant says one of Lehman\u2019s laws of software evolution. Many studies have been presented in the literature that investigate the evolution of software systems but few have focused on the evolution of technical debt. In this paper we study sixty-six Java open-source software projects from the Apache ecosystem focusing on the evolution of technical debt. We analyze the evolution of these systems over the past five years at the temporal granularity level of weekly snapshots. We calculate the trends of the technical debt time series but we also investigate the lower-level constituent components of this technical debt. We aggregate some of the information to the ecosystem level. Our findings show that the technical debt together with source code metrics increase for the majority of the systems. However, technical debt normalized to the size of the system actually decreases over time in the majority of the systems under investigation. Furthermore, we discover that some of the most frequent and time-consuming types of technical debt are related to improper exception handling and code duplication.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Technical Debt\": \"In software-intensive systems, technical debt consists of design or implementation constructs that are expedient in the short term, but set up a technical context that can make a future change more costly or impossible. Technical debt is a contingent liability whose impact is limited to internal system qualities, primarily maintainability and evolvability.\"}, \"Research Object\": [\"Technical Debt\"]}\n"}
{"prompt":"{ADOOPLA} - Combining Product-Line- and Product-Level Criteria in Multi-objective Optimization of Product Line Architectures\n\nProduct lines of software-intensive systems have a great diversity of features and products, which leads to vast design spaces that are difficult to explore. In addition, finding optimal product line system architectures usually requires a consideration of several quality trade-offs at once, involving both product-level as well as product-line-wide criteria. This challenge cannot be solved manually for all but the smallest problems, and can therefore benefit from automated support. In this paper we propose ADOOPLA, a tool-supported approach for the optimization of product line system architectures. In contrast to existing approaches where product-level approaches only support product-level criteria and product-line oriented approaches only support product-line-wide criteria, our approach integrates criteria from both levels in the optimization of product line architectures. Further, the approach can handle multiple objectives at once, supporting the architect in exploring the multi-dimensional Pareto-front of a given problem. We describe the theoretical principles of the ADOOPLA approach and demonstrate its application to a simplified case study from the automotive domain.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Optimization Method\": \"A method to optimize existing architectures (implemented or designed) regarding specific qualities or properties.\"}, \"Research Object\": [\"Architecture Optimization Method\"]}\n"}
{"prompt":"Constructing a Shared Infrastructure for Software Architecture Analysis and Maintenance\n\nOver the past three decades software engineering researchers have produced a wide range of techniques and tools for understanding the architectures of large, complex systems. However, these have tended to be one-off research projects, and their idiosyncratic natures have hampered research collaboration, extension and combination of the tools, and technology transfer. The area of software architecture is rich with disjoint research and development infrastructures, and datasets that are either proprietary or captured in proprietary formats. This paper describes a concerted effort to reverse these trends. We have designed and implemented a flexible and extensible infrastructure (SAIN) with the goal of sharing, replicating, and advancing software architecture research. We have demonstrated that SAIN is capable of incorporating the constituent tools extracted from three independently developed, large, long-lived software architecture research environments. We discuss SAIN's ambitious goals, the challenges we have faced in achieving those goals, the key decisions made in SAIN's design and implementation, the lessons learned from our experience to date, and our ongoing and future work.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Analysis Method\": \"A method for analyzing existing software architectures, e.g., to measure or evaluate specific qualities or functions.\", \"Architecture Extraction\": \"Designing and realizing methods and algorithms to automatically extract architecture information from existing implementations.\"}, \"Research Object\": [\"Architecture Analysis Method\", \"Architecture Extraction\"]}\n"}
{"prompt":"An Empirical Study of Architectural Decay in Open-Source Software\n\nArchitecture is the set of principal design decisions about a software system. In practice, new architectural decisions are added and existing ones reversed or modified throughout a system's lifetime. Frequently, these decisions deviate from the architect's well-considered intent, and software systems regularly exhibit increased architectural decay as they evolve. The manifestations of such ill-considered design decisions are seen as \u201carchitectural smells\u201d. To date, there has been no in-depth study of the characteristics or trends involving this phenomenon. Instead, when referring to architectural smells and their negative effects, both researchers and practitioners had to rely on folklore and their personal, inherently limited experience. In this paper, we report on the systematic step we have taken in investigating the nature and impact of architectural smells. We have selected a set of representative architectural smells from literature and analyzed their instances in 421 versions from 8 open-source software systems. We have (1) developed algorithms to automatically detect instances of multiple architectural smell types, and (2) analyzed relationships between the detected smells and the lists of issues reported in the systems' respective issue trackers. Our study shows that architectural smells have tangible negative consequences in the form of implementation issues as well as code commits requiring increased maintenance effort throughout a system's lifetime.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Evolution\": \"The process of maintaining and adapting existing software architecture to meet requirements and environmental changes [Imran et al., 2016]. This includes papers that investigate the evolution of specific architectures.\"}, \"Research Object\": [\"Architecture Evolution\"]}\n"}
{"prompt":"Infrastructure-as-Code for Data-Intensive Architectures: {A} Model-Driven Development Approach\n\nAs part of the DevOps tactics, Infrastructure-as-Code (IaC) provides the ability to create, configure, and manage complex infrastructures by means of executable code. Writing IaC, however, is not an easy task, since it requires blending different infrastructure programming languages and abstractions, each specialized on a particular aspect of infrastructure creation, configuration, and management. Moreover, the more the architectures become large and complex (e.g. Data-Intensive or Microservice-based architectures), the more dire the need of IaC becomes. The goal of this paper is to exploit Model-Driven Engineering (MDE) to create language-agnostic models that are then automatically transformed into IaC. We focus on the domain of Data-Intensive Applications as these typically exploit complex infrastructures which demand sophisticated and fine-grained configuration and re-configuration - we show that, through our approach, called DICER, it is possible to create complex IaC with significant amounts of time savings, both in IaC design as well as deployment and re-deployment times.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Description Language\": \"A formal or software language to create a description of a software architecture, i.e., \\\"any form of expression for use in architecture descriptions\\\" [ISO\/IEC 42010]. Papers propose or extend an existing architecture description language.\"}, \"Research Object\": [\"Architecture Description Language\"]}\n"}
{"prompt":"Providing Context as a Service Using Service-Oriented Mobile Indie Fog and Opportunistic Computing\n\nThe increasing number of sensor-embedded mobile devices has motivated the research of mobile Sensing as a Service in which mobile devices can host Web servers to serve sensory data to the Internet of Things systems, urban crowd sensing systems and big data acquisition systems. Further, the improved processing power of modern mobile devices indicates the mobile devices are not only capable of serving sensory data but also capable of providing Context as a Service (CaaS) based on requesters\u2019 own interpretation algorithms. In order to demonstrate mobile CaaS, this paper proposes a service-oriented mobile Indie Fog server architecture, which enables dynamic algorithm execution and also supports distributed CaaS processing among mobile devices. Moreover, in order to optimise the process distribution, the proposed framework also encompasses a resource-aware process assignment scheme known as MIRA. Finally, the authors have implemented and evaluated the proposed framework on a number of real devices. Accordingly, the evaluation results show that the MIRA scheme can improve the process assignment in the collaborative mobile CaaS environment.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Reference Architecture\": \"A description of an architecture (e.g., domain-specific or to solve recurring problems) that can be tailored to specific use cases.\"}, \"Research Object\": [\"Reference Architecture\"]}\n"}
{"prompt":"Microservice Architecture in Reality: An Industrial Inquiry\n\nBackground: Seeking an appropriate architecture for a software design is always a challenge in recent decades. Although microservices as a lightweight architecture style is claimed that can improve the current practices with several characteristics, many practices are based upon the different circumstances and reflect the variant effects. An empirical inquiry brings us a systematic insight into the industrial practices on microservices. Objective: This study is to investigate the gap between the ideal visions and real industrial practices on microservices and what benefits we can gain from the industrial experiences. Method: We carried out a series of industrial interviews with thirteen different types of companies. The collected data were then codified according to the defined qualitative methods. Results: We characterized the gaps between the typical characteristics accepted in the community and the industrial practices of microservices. Furthermore, the compromise between benefits and sufferings of microservices around these nine dimensions were also investigated. Conclusion: We confirmed the benefits of the microservices that can be obtained from practice as well as their possible pains that need to be addressed with extra expense from experiences. Besides, some outlined pains, e.g., organizational transformation, decomposition, distributed monitoring, and bug localization, may inspire researchers to conduct the further research.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Pattern\": \"An architectural pattern is a general, reusable solution to a commonly occurring problem in software architecture within a given context. Patterns with negative effects on the product, i.e., anti-patterns, are also included here.\"}, \"Research Object\": [\"Architecture Pattern\"]}\n"}
{"prompt":"{PARAD} Repository: On the Capitalization of the Performance Analysis Process for {AADL} Designs\n\nIn this paper, we focus on RTES (real-time embedded systems) designs expressed in AADL (Architecture and Analysis Design Language) and we propose a model-based approach to improve the way that designers check and analyze the performance of their system designs by capitalizing the analysis process. Our approach is based on proposing customized repositories of models using formal AADL-compliant query and constraint languages in order to orient designers to choose the most suitable analysis models and tests. Furthermore, this work is also dedicated to research teams to share their researches and prototypes, in order to enhance the (re-)usability of the real-time performance analysis tests.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Analysis Method\": \"A method for analyzing existing software architectures, e.g., to measure or evaluate specific qualities or functions.\"}, \"Research Object\": [\"Architecture Analysis Method\"]}\n"}
{"prompt":"Guidelines for Architecting Android Apps: {A} Mixed-Method Empirical Study\n\nFor surviving in the highly competitive market of Android apps, it is fundamental for app developers to deliver apps of high quality and with short release times. A well-architected Android app is beneficial for developers, e.g. in terms of maintainability, testability, performance, and avoidance of resource leaks. However, how to properly architect Android apps is still debated and subject to conflicting opinions usually influenced by technological hypes rather than objective evidence. In this paper we present an empirical study on how developers architect Android apps, what architectural patterns and practices Android apps are based on, and their potential impact on quality. We apply a mixed-method empirical research design that combines (i) semi-structured interviews with Android practitioners in the field and (ii) a systematic analysis of both the grey (i.e., websites, Online blogs) and white literature (i.e., academic studies) on the architecture of Android apps. Based on the analysis of the state of the art and practice about architecting Android apps, we systematically extract a set of 42 evidence-based guidelines supporting developers when architecting their Android apps.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Design Method\": \"A method for designing software architectures, e.g., to obtain specific qualities or functions.\"}, \"Research Object\": [\"Architecture Design Method\"]}\n"}
{"prompt":"Identifying {Domain}-{Based} {Cyclic} {Dependencies} in {Microservice} {APIs} {Using} {Source} {Code} {Detectors}\n\nIsolation, autonomy, and loose coupling are critical success factors of microservice architectures. Unfortunately, systems tend to become strongly coupled over time, sometimes even exhibiting cyclic communication chains, making the individual deployment of services challenging. Such chains are highly problematic when strongly coupled communication e.g. based on synchronous invocations is used, but also create complexity and maintenance issues in more loosely coupled asynchronous or event-based communication. Here, cycles only manifest on a conceptual or domain level, making them hard to track for algorithms that rely solely on static analysis. Accordingly, previous attempts to detect cycles either focused on synchronous communication or had to collect additional runtime data, which can be costly and time-consuming. We suggest a novel approach for identifying and evaluating domain-based cyclic dependencies in microservice systems based on modular, reusable source code detectors. Based on the architecture model reconstructed by the detectors, we derived a set of architectural metrics for detecting and classifying domain-based cyclical dependencies. By conducting two case studies on open-source microservice architectures, we validated the feasibility and applicability of our approach.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architectural Aspects\": \"A method for identifying or specifying specific architectural aspects in existing implemented architectures, e.g., automatically identifying transactional contexts in an architecture. Note that if you analyze an architecture description containing these aspects, the analysis is a separate research object.\", \"Architecture Analysis Method\": \"A method for analyzing existing software architectures, e.g., to measure or evaluate specific qualities or functions.\"}, \"Research Object\": [\"Architecture Analysis Method\", \"Architectural Aspects\"]}\n"}
{"prompt":"Self-Commissioning Industrial IoT-Systems in Process Automation: {A} Reference Architecture\n\nDistributed control systems are currently evolving towards Industrial Internet-of-Things (IIoT) systems. However, they still suffer from complex commissioning processes that incur high costs. Researchers have proposed several so-called \"Plug and Produce\" (PnP) approaches, where commissioning shall be largely automated, but they have suffered from semantic ambiguities and usually rely on proprietary information models. We propose a novel reference architecture for PnP in IIoT systems, which is based on OPC UA and PLCopen standards and can reduce industrial device commissioning times across vendor products to a few seconds. Our proof-of-concept implementation can handle more than 500 signals per millisecond during runtime, sufficient for most application scenarios.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Reference Architecture\": \"A description of an architecture (e.g., domain-specific or to solve recurring problems) that can be tailored to specific use cases.\"}, \"Research Object\": [\"Reference Architecture\"]}\n"}
{"prompt":"Data-Centric Communication and Containerization for Future Automotive Software Architectures\n\nContext: The functional interconnection and data routing in today's automotive electric\/electronic architectures has reached a level of complexity which is hardly manageable and error-prone. This circumstance severely hinders short times from development to operation. Aim: The purpose of the study is to evaluate the feasibility of Data Distribution Services in accord with containerization technologies in an agile development process for automotive software. Method: We propose to represent services by means of topics in a data-centric publish-subscribe approach. We conduct performance benchmarks to evaluate its aptitude and present a case study illustrating fail-operational behavior in a setup recreated from highly automated driving. Results: Backed by the results and the case study we show that containerized services, along with data-centric messaging, manage to meet most of our proposed requirements. We furthermore reveal limitations of the used technology stack and discuss remedies to their shortcomings.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Description\": \"An Architecture Description (AD) is a work product used to express the Architecture of some System Of Interest. An AD describes one possible Architecture for a System Of Interest. An AD may take the form of a document, a set of models, a model repository, or some other form [ISO\/IEC 42010]. Papers use existing architecture description languages to describe architectures.\", \"Architecture Design Method\": \"A method for designing software architectures, e.g., to obtain specific qualities or functions.\"}, \"Research Object\": [\"Architecture Description\", \"Architecture Design Method\"]}\n"}
{"prompt":"Workload-Based Clustering of Coherent Feature Sets in Microservice Architectures\n\nIn a microservice architecture, each service is designed to be independent of other microservices. The size of a microservice, defined by the features it provides, directly impacts its performance and availability. However, none of the currently available approaches take this into account. This paper proposes an approach to improve the performance of a microservice architecture by workload-based feature clustering. Given a feature model, the current microservice architecture, and the workload, this approach recommends a deployment that improves the performance for the given workload using a genetic algorithm. We created MicADO, an open-source tool, in which we implemented this approach, and applied it in a case study on an ERP system. For different workloads, the resulting generated microservice architectures show substantial improvements, which sets the potential of the approach.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Optimization Method\": \"A method to optimize existing architectures (implemented or designed) regarding specific qualities or properties.\"}, \"Research Object\": [\"Architecture Optimization Method\"]}\n"}
{"prompt":"An Architecture for Decentralized, Collaborative, and Autonomous Robots\n\nRobotic applications are typically realized using ad hoc and domain-specific solutions, which challenges the engineering and cross-project reuse of such applications. Especially in complex scenarios, where self-adaptive robots collaborate among themselves or with humans, the effective and systematic engineering of such applications is becoming increasingly important. Such scenarios require decentralized software architectures that foster fault-tolerant ways of managing large teams of (possibly) heterogeneous robots. To the best of our knowledge, no existing architecture for robot applications supports decentralized and self-adaptive collaboration. To address this gap, we conducted a design science study with 21 practitioners and experts in the field of robotics to develop an architecture fulfilling these requirements through several iterations. We present SERA, an architecture for robot applications that supports human-robot collaboration, as well as adaptation and coordination of single- and multi-robot systems in a decentralized fashion. SERA is based on layers that contain components that manage the adaptation at different levels of abstraction and communicate through well-defined interfaces. We successfully validated SERA by considering a set of real scenarios, by both using simulators and real robots, by involving robotic experts, and by benchmarking it with state-of-the-art solutions.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Reference Architecture\": \"A description of an architecture (e.g., domain-specific or to solve recurring problems) that can be tailored to specific use cases.\"}, \"Research Object\": [\"Reference Architecture\"]}\n"}
{"prompt":"{ACE:} Easy Deployment of Field Optimization Experiments\n\nOptimization of software parameters is a recurring activity in the life-cycle of many software products, from prototypes and simulations, test beds and hardware-in-the-loop scenarios, field calibrations to the evolution of continuous deployment cycles. To perform this activity, software companies require a combination of software developers and optimization experts with domain specific knowledge. Moreover, in each of life-cycle steps, companies utilize a plethora of different tools, tailored for specific domains or development stages. To most companies, this scenario leads to an excessive cost in the optimization of smaller features or in cases where it is not clear what the returned value will be. In this work we present a new optimization system based on field experiments, that is aimed to facilitate the adoption of optimization in all stages of development. We provide two main contributions. First, we present the architecture of a new optimization system that allows existing software systems to perform optimization procedures in different domains and in different development stages. This optimization system utilizes domain-agnostic interfaces to allow existing systems to perform optimization procedures with minimal invasiveness and optimization expertise. Second, we provide an overview of the deployments, discuss the advantages and limitations and evaluate the optimization system in three empirical scenarios: (1) offline optimization with simulations; (2) optimization of a communication system in a test bed in collaboration with Ericsson; (3) live optimization of a mobile application in collaboration with Sony Mobile. We aim to provide practitioners with a single optimization tool that can leverage their optimization activities from offline to live systems, with minimal invasiveness and optimization expertise.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Optimization Method\": \"A method to optimize existing architectures (implemented or designed) regarding specific qualities or properties.\"}, \"Research Object\": [\"Architecture Optimization Method\"]}\n"}
{"prompt":"An Architectural View for Data Protection by Design\n\nData Protection by Design (DPbD) is a truly interdisciplinary effort that involves many stakeholders such as legal experts, requirements engineers, software architects, developers, and system operators. Building software-intensive systems that respect the fundamental rights to privacy and data protection is the result of intensive dialogue and careful trade-off decisions. In practice however, there is a dichotomy between the legal reasoning which is conducted in Data Protection Impact Assessments (DPIA) and software engineering approaches, such as threat modeling, aimed at identifying privacy requirements and privacy risks. These activities are commonly performed in total isolation, which negatively impacts (i) the compliance exercise, (ii) the ability to evolve the system over time, and (iii) the architectural trade-offs made during system design. In this article, we present an architectural viewpoint for describing software architectures from a legal, data protection perspective whose core modeling abstractions are based on an in-depth legal analysis of the EU General Data Protection Regulation. This viewpoint is tied to Data Flow Diagrams-commonly used in threat modeling-through correspondence rules. The proposed viewpoint supports the automation of a number of data protection impact assessment steps through (i) meta-model constraints, (ii) model analysis, and (iii) interaction with the involved stakeholders. This enables a streamlined compliance exercise, reconciling legal privacy and data protection notions with architecture-driven software engineering practices. We validate our approach in the context of a realistic e-health application for a number of complementary development scenarios.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architectural Aspects\": \"A method for identifying or specifying specific architectural aspects in existing implemented architectures, e.g., automatically identifying transactional contexts in an architecture. Note that if you analyze an architecture description containing these aspects, the analysis is a separate research object.\"}, \"Research Object\": [\"Architectural Aspects\"]}\n"}
{"prompt":"Monolith Migration Complexity Tuning Through the Application of Microservices Patterns\n\nThe microservices architecture has become mainstream for the development of business applications because it supports the adaptation of scalability to the type of demand, but, most importantly, because it fosters an agile development process based on small teams focused on the product. Therefore, there is the need to migrate the existing monolith systems to microservices. Current approaches to the identification of candidate microservices in a monolith neglect the cost of redesigning the monolith functionality due to the impact of the CAP theorem. In this paper we propose a redesign process, guided by a set of complexity metrics, that allows the software architect to analyse and redesign the monolith functionality given a candidate decomposition. Both, the redesign process and the metrics are evaluated in the context of candidate decompositions of two monolith systems.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Optimization Method\": \"A method to optimize existing architectures (implemented or designed) regarding specific qualities or properties.\"}, \"Research Object\": [\"Architecture Optimization Method\"]}\n"}
{"prompt":"Migrating Towards Microservice Architectures: An Industrial Survey\n\nMicroservices are gaining tremendous traction in industry and a growing scientific interest in academia. More and more companies are adopting this architectural style for modernizing their products and taking advantage of its promised benefits (e.g., agility, scalability). Unfortunately, the process of moving towards a microservice-based architecture is anything but easy, as there are plenty of challenges to address from both technical and organizational perspectives. In this paper we report about an empirical study on migration practices towards the adoption of microservices in industry. Specifically, we designed and conducted a survey targeting practitioners involved in the process of migrating their applications and we collected information (by means of interviews and questionnaires) on (i) the performed activities, and (ii) the challenges faced during the migration. Our findings benefit both (i) researchers by highlighting future directions for industryrelevant problems and (ii) practitioners by providing a reference framework for their (future) migrations towards microservices.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Evolution\": \"The process of maintaining and adapting existing software architecture to meet requirements and environmental changes [Imran et al., 2016]. This includes papers that investigate the evolution of specific architectures.\"}, \"Research Object\": [\"Architecture Evolution\"]}\n"}
{"prompt":"Improving the Consistency and Usefulness of Architecture Descriptions: Guidelines for Architects\n\nThe need to support software architecture evolution has been well recognized, even more since the rise of agile methods. However, assuring the conformance between architecture descriptions and the implementation remains challenging. Inconsistencies emanate among multiple architecture descriptions, and between architecture descriptions and code. As a consequence, architecture descriptions are not always trusted and used to the extent that their authors wish for. In this paper, we present two surveys with 93 and 72 participants to examine architectural inconsistencies, with a focus on how they evolve over time and can be mitigated using practical guidelines. We identified the importance of capturing emerging elements to keep the architecture description consistent with the implementation, and consider the current-state and future-state architecture separately. Consequences of inconsistencies typically arise at later stages, especially if an architecture description concerns multiple teams. Our guidelines suggest to limit the upfront architecture to stable decisions, while paying attention to concerns that matter across team borders. In the ideal case, companies should aim to integrate architects into the teams to capture emerging aspects with time.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architectural Assumptions\": \"Assumptions are the reasons for architectural decisions that are more or less arbitrarily taken on the fly because of personal experience, background, domain knowledge, the artifacts reused, and the like\", \"Architecture Evolution\": \"The process of maintaining and adapting existing software architecture to meet requirements and environmental changes [Imran et al., 2016]. This includes papers that investigate the evolution of specific architectures.\"}, \"Research Object\": [\"Architecture Evolution\", \"Architectural Assumptions\"]}\n"}
{"prompt":"A Survey on Big Data Analytics Solutions Deployment\n\nThere are widespread and increasing interest in big data analytics (BDA) solutions to enable data collection, transformation, and predictive analyses. The development and operation of BDA application involve business innovation, advanced analytics and cutting-edge technologies which add new complexities to the traditional software development. Although there is a growing interest in BDA adoption, successful deployments are still scarce (a.k.a., the \u201cDeployment Gap\u201d phenomenon). This paper reports an empirical study on BDA deployment practices, techniques and tools in the industry from both the software architecture and data science perspectives to understand research challenges that emerge in this context. Our results suggest new research directions to be tackled by the software architecture community. In particular, competing architectural drivers, interoperability, and deployment procedures in the BDA field are still immature or have not been adopted in practice.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Design Method\": \"A method for designing software architectures, e.g., to obtain specific qualities or functions.\"}, \"Research Object\": [\"Architecture Design Method\"]}\n"}
{"prompt":"Incremental Calibration of Architectural Performance Models with Parametric Dependencies\n\nArchitecture-based Performance Prediction (AbPP) allows evaluation of the performance of systems and to answer what-if questions without measurements for all alternatives. A difficulty when creating models is that Performance Model Parameters (PMPs, such as resource demands, loop iteration numbers and branch probabilities) depend on various influencing factors like input data, used hardware and the applied workload. To enable a broad range of what-if questions, Performance Models (PMs) need to have predictive power beyond what has been measured to calibrate the models. Thus, PMPs need to be parametrized over the influencing factors that may vary. Existing approaches allow for the estimation of the parametrized PMPs by measuring the complete system. Thus, they are too costly to be applied frequently, up to after each code change. Moreover, they do not keep manual changes to the model when recalibrating. In this work, we present the Continuous Integration of Performance Models (CIPM), which incrementally extracts and calibrates the performance model, including parametric dependencies. CIPM responds to source code changes by updating the PM and adaptively instrumenting the changed parts. To allow AbPP, CIPM estimates the parametrized PMPs using the measurements (generated by performance tests or executing the system in production) and statistical analysis, e.g., regression analysis and decision trees. Additionally, our approach responds to production changes (e.g., load or deployment changes) and calibrates the usage and deployment parts of PMs accordingly. For the evaluation, we used two case studies. Evaluation results show that we were able to calibrate the PM incrementally and accurately.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Evolution\": \"The process of maintaining and adapting existing software architecture to meet requirements and environmental changes [Imran et al., 2016]. This includes papers that investigate the evolution of specific architectures.\"}, \"Research Object\": [\"Architecture Evolution\"]}\n"}
{"prompt":"Modeling of Parametric Dependencies for Performance Prediction of Component-Based Software Systems at Run-Time\n\nModel-based performance analysis can be leveraged to explore performance properties of software systems. To capture the behavior of varying workload mixes, configurations, and deployments of a software system requires formal modeling of the impact of configuration parameters and user input on the system behavior. Such influences are represented as parametric dependencies in software performance models. Existing modeling approaches focus on modeling parametric dependencies at design-time. This paper identifies runtime specific parametric dependency features, which are not supported by existing work. Therefore, this paper proposes a novel modeling methodology for parametric dependencies and a corresponding graph-based resolution algorithm. This algorithm enables the solution of models containing component instance-level dependencies, variables with multiple descriptions in parallel, and correlations modeled as parametric dependencies. We integrate our work into the Descartes Modeling Language (DML), allowing for accurate and efficient modeling and analysis of parametric dependencies. These performance predictions are valuable for various purposes such as capacity planning, bottleneck analysis, configuration optimization and proactive auto-scaling. Our evaluation analyzes a video store application. The prediction for varying language mixes and video sizes shows a mean error below 5% for utilization and below 10% for response time.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Optimization Method\": \"A method to optimize existing architectures (implemented or designed) regarding specific qualities or properties.\"}, \"Research Object\": [\"Architecture Optimization Method\"]}\n"}
{"prompt":"State of the {Practice} in {Application} {Programming} {Interfaces} ({APIs}): {A} {Case} {Study}\n\nApplication Programming Interfaces (APIs) have become prevalent in\u00a0today\u2019s software systems and services. APIs are basically a technical means to realize the co-operation between software systems or services. While there are several guidelines for API development, the actually applied practices and challenges are less clear. To better understand the state of the practice of API development and management in the industry, we conducted a descriptive case study in four Finnish software companies: two consultancy companies developing software for their customers, and two companies developing their software products. As a result, we identified five different usage scenarios for APIs and emphasize that diversity of usage should be taken into account more explicitly especially in research. API development and technical management are well supported by the existing tools and technologies especially available from the cloud technology. This leaves as the main challenge the selection of the right technology from the existing technology stack. Documentation and usability are practical issues to be considered and often less rigorously addressed. However, understanding what kind of API management model to apply for the business context appears as the major challenge. We also suggest considering APIs more clearly a separate concern in the product management with specific practices, such as API roadmapping.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architectural Aspects\": \"A method for identifying or specifying specific architectural aspects in existing implemented architectures, e.g., automatically identifying transactional contexts in an architecture. Note that if you analyze an architecture description containing these aspects, the analysis is a separate research object.\", \"Architecture Decision Making\": \"In software development and evolution, decision-making is an integral part. Various decisions are being made throughout the software development life cycle concerning processes, products, tools, methods, and techniques. From a decision-making perspective, all these questions are confronted by different objectives and constraints, a huge number of variables under dynamically changing requirements, processes, actors, stakeholders, tools, and techniques. This is combined with incomplete, fuzzy or inconsistent information about all the involved artifacts. [Ruhe2003]\"}, \"Research Object\": [\"Architectural Aspects\", \"Architecture Decision Making\"]}\n"}
{"prompt":"Empowering SysML-Based Software Architecture Description with Formal Verification: From SysADL to {CSP}\n\nSoftware architecture description languages (ADLs) currently adopted by industry for software-intensive systems are largely semi-formal and essentially based on SysML and specialized profiles. Despite these ADLs allow describing both structure and behavior of the architecture, there is no guarantee regarding the satisfaction of correctness properties. Due to their nature, semi-formal ADLs do not support automated verification of the specified properties, in particular those related to safety and liveness of the specified behavior. This paper proposes a novel approach for empowering SysML-based ADLs with formal verification support founded on model checking. It presents (i) how the semantics of SysADL, a SysML-based ADL, can be formalized in terms of the CSP process calculus, (ii) how correctness properties can be formally specified in CSP, and (iii) how the FDR4 refinement checker allows verifying correctness properties through model checking. The automated model transformation from SysADL architecture descriptions to CSP composite processes has been implemented as a plug-in\u00a0to the Eclipse-based SysADL Studio tool. This paper also describes an application of SysADL empowered with CSP to validate its usefulness in practice.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Description Language\": \"A formal or software language to create a description of a software architecture, i.e., \\\"any form of expression for use in architecture descriptions\\\" [ISO\/IEC 42010]. Papers propose or extend an existing architecture description language.\"}, \"Research Object\": [\"Architecture Description Language\"]}\n"}
{"prompt":"Testing the Implementation of Concurrent {AUTOSAR} Drivers Against Architecture Decisions\n\nConcurrent software based on a shared-memory model is predominant in industrial applications that cannot afford to execute complex message-passing libraries. However, direct access to shared memory creates implicit dependencies between concurrently executing components. Therefore, the development and maintenance of such software is hard. In this paper, we argue the need to manage, at the architectural level, the implicitly high coupling between concurrent components that share memory. We suggest an approach that verifies architectural specifications against the implementation and finds potential mismatches. While static analysis approaches can be complete and verify all possible mismatches, they are often imprecise, leading to a large number of false warnings, especially in concurrent software. Instead, we built our approach, using dynamic analysis, on top of one of the most well-known algorithms for detecting data races, Eraser Lockset, and extended its model to support features required for the verification process. Since Lockset operates on the execution traces, test cases that produce these traces must ensure proper coverage. Therefore, we argue the need to use test cases conforming to the strict modified condi-tion\/decision coverage criteria (MC\/DC). Our version of Lockset takes advantage of the fact that possible shared memory locations are known in advance. We further improved its precision by considering atomic operations as a synchronization mechanism. The approach was evaluated on industrial AUTOSAR drivers that execute concurrently.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Analysis Method\": \"A method for analyzing existing software architectures, e.g., to measure or evaluate specific qualities or functions.\"}, \"Research Object\": [\"Architecture Analysis Method\"]}\n"}
{"prompt":"{FLRA}: {A} {Reference} {Architecture} for {Federated} {Learning} {Systems}\n\nFederated learning is an emerging machine learning paradigm that enables multiple devices to train models locally and formulate a global model, without sharing the clients\u2019 local data. A federated learning system can be viewed as a large-scale distributed system, involving different components and stakeholders with diverse requirements and constraints. Hence, developing a federated learning system requires both software system design thinking and machine learning knowledge. Although much effort has been put into federated learning from the machine learning perspectives, our previous systematic literature review on the area shows that there is a distinct lack of considerations for software architecture design for federated learning. In this paper, we propose FLRA, a reference architecture for federated learning systems, which provides a template design for federated learning-based solutions. The proposed FLRA reference architecture is based on an extensive review of existing patterns of federated learning systems found in the literature and existing industrial implementation. The FLRA reference architecture consists of a pool of architectural patterns that could address the frequently recurring design problems in federated learning architectures. The FLRA reference architecture can serve as a design guideline to assist architects and developers with practical solutions for their problems, which can be further customised.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Reference Architecture\": \"A description of an architecture (e.g., domain-specific or to solve recurring problems) that can be tailored to specific use cases.\"}, \"Research Object\": [\"Reference Architecture\"]}\n"}
{"prompt":"System- and Software-level Architecting Harmonization Practices for Systems-of-Systems : An exploratory case study on a long-running large-scale scientific instrument\n\nThe problems caused by the gap between system- and software-level architecting practices, especially in the context of Systems of Systems where the two disciplines inexorably meet, is a well known issue with a disappointingly low amount of works in the literature dedicated to it. At the same time, organizations working on Systems of Systems have been developing solutions for closing this gap for many years now. This work aims to extract such knowledge from practitioners by studying the case of a large-scale scientific instrument, a geographically distributed radio telescope to be more specific, developed as a sequence of projects during the last two decades. As the means for collecting data for this study we combine online interviews with a virtual focus group of practitioners from the organization responsible for building the instrument. Through this process, we identify persisting problems and the best practices that have been developed to deal with them, together with the perceived benefits and drawbacks of applying the latter in practice. Some of our major findings include the need to avoid over-reliance on the flexibility of software to compensate for incomplete requirements, hidden assumptions, as well as late involvement of system architecting, and to facilitate the cooperation between the involved disciplines through dedicated architecting roles and the adoption of unifying practices and standards.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Decision Making\": \"In software development and evolution, decision-making is an integral part. Various decisions are being made throughout the software development life cycle concerning processes, products, tools, methods, and techniques. From a decision-making perspective, all these questions are confronted by different objectives and constraints, a huge number of variables under dynamically changing requirements, processes, actors, stakeholders, tools, and techniques. This is combined with incomplete, fuzzy or inconsistent information about all the involved artifacts. [Ruhe2003]\"}, \"Research Object\": [\"Architecture Decision Making\"]}\n"}
{"prompt":"Reducing Development Overheads with a Generic and Model-Centric Architecture for Online Games\n\nThe development of an online game requires not only the content, visual and auditory design but also a considerable amount of effort for planning, creating and operating the infrastructure for exchanging information between players and backend. Within the context of building an own browser-based massively multiplayer online game, questions like how information of this kind can be exchanged arise. Within this paper, various strategies were planned, developed and evaluated to provide the helpful basis for a platform decision. These strategies do not feel very \u201cgame-like\u201d. As a result of this, we created an alternative approach as a runtime environment for games of this kind, which has to simplify the conventional strategies for making games: our GameEngine. This environment combines code generation for clients, automated data transformation, platform independent remote procedure calls and lifecycle management for entities. This paper targets to outline the different strategies for game realisation, and analyses the efforts in comparison to our approach in various applications. Proprietary TCP-based approaches are taken into account, as well as standardised web technologies and currently available runtime environments for game development. All approaches indicated a significant increase in effort for the implementation of various examples. An additional effort that can be nearly avoided, and is achieved with our approach.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Pattern\": \"An architectural pattern is a general, reusable solution to a commonly occurring problem in software architecture within a given context. Patterns with negative effects on the product, i.e., anti-patterns, are also included here.\"}, \"Research Object\": [\"Architecture Pattern\"]}\n"}
{"prompt":"A Flexible Architecture for Key Performance Indicators Assessment in Smart Cities\n\n\nThe concept of smart and sustainable city has been on the agenda for the last decade. Smart governance is about the use of innovation for supporting enhanced decision making and planning to make a city smart, by leveraging on Key Performance Indicators (KPIs) as procedural tools. However, developing processes and instruments able to evaluate smart cities is still a challenging task, due to the rigidity showed by the existing frameworks in the definition of KPIs and modeling of the subjects to be evaluated. Web-based platforms, spreadsheets or even Cloud-based applications offer limited flexibility, if the stakeholder is interested not only in using but also in defining the pieces of the puzzle to be composed. In this paper we present a flexible architecture supporting a model-driven approach for the KPIs assessment in smart cities. It identifies both required and optional components and functionalities needed for realizing the automatic KPIs assessment, while showing flexibility points allowing for different specification of the architecture, thus of the overall methodology.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Reference Architecture\": \"A description of an architecture (e.g., domain-specific or to solve recurring problems) that can be tailored to specific use cases.\"}, \"Research Object\": [\"Reference Architecture\"]}\n"}
{"prompt":"Enabling Continuous Software Engineering for Embedded Systems Architectures with Virtual Prototypes\n\nContinuous software engineering aims at orchestrating engineering knowledge from various disciplines in order to deal with the rapid changes within the ecosystems of which software-based systems are part of. The literature claims that one means to ensure these prompt responses is to incorporate virtual prototypes of the system as early as possible in the development process, such that requirements and architecture decisions are verified early and continuously by means of simulations. Despite the maturity of practices for designing and assessing architectures, as well as for virtual prototyping, it is still not clear how to jointly consider the practices from these disciplines within development processes, in order to address the dynamics imposed by continuous software engineering. In this regard, we discuss in this paper how to orchestrate architecture drivers and design specification techniques with virtual prototypes, to address the demands of continuous software engineering in development processes. Our proposals are based on experiences from research and industry projects in various domains such as automotive, agriculture, construction, and medical devices.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Design Method\": \"A method for designing software architectures, e.g., to obtain specific qualities or functions.\"}, \"Research Object\": [\"Architecture Design Method\"]}\n"}
{"prompt":"Evaluating the Effectiveness of Multi-level Greedy Modularity Clustering for Software Architecture Recovery\n\nSoftware architecture recovery approaches mainly analyze various types of dependencies among software modules to group them and reason about the high-level structural decomposition of a system. These approaches employ a variety of clustering techniques. In this paper, we present an empirical evaluation of a modularity clustering technique used for software architecture recovery. We use five open source projects as subject systems for which the ground-truth architectures were known. This dataset was previously prepared and used in an empirical study for evaluating four state-of-the-art architecture recovery approaches and their variants as well as two baseline clustering algorithms. We used the same dataset for an evaluation of multi-level greedy modularity clustering. Results showed that MGMC outperforms all the other SAR approaches in terms of accuracy and modularization quality for most of the studied systems. In addition, it scales better to very large systems for which it runs orders-of-magnitude faster than all the other algorithms.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Extraction\": \"Designing and realizing methods and algorithms to automatically extract architecture information from existing implementations.\"}, \"Research Object\": [\"Architecture Extraction\"]}\n"}
{"prompt":"Synthesis and Quantitative Verification of Tradeoff Spaces for Families of Software Systems\n\nDesigning software subject to uncertainty in a way that provides guarantees about its run-time behavior while achieving an acceptable balance between multiple extra-functional properties is still an open problem. Tools and techniques to inform engineers about poorly-understood design spaces in the presence of uncertainty are needed. To tackle this problem, we propose an approach that combines synthesis of spaces of system design alternatives from formal specifications of architectural styles with probabilistic formal verification. The main contribution of this paper is a formal framework for specification-driven synthesis and analysis of design spaces that provides formal guarantees about the correctness of system behaviors and satisfies quantitative properties (e.g., defined over system qualities) subject to uncertainty, which is factored as a first-class entity.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Design Method\": \"A method for designing software architectures, e.g., to obtain specific qualities or functions.\"}, \"Research Object\": [\"Architecture Design Method\"]}\n"}
{"prompt":"Mapping Features to Source Code through Product Line Architecture: Traceability and Conformance\n\nExisting software product line approaches often develop and evolve product line features, architecture, and source code independently, which makes it difficult to manage the relationship and conformance between these artifacts. This paper presents a novel approach using the architecture as a pivot to address this problem. It consists of a modeling mechanism that integrates features specification into an architectural model, and an architecture-implementation mapping mechanism that combines code generation with annotation processing. The approach can trace a product line feature to the architecture and source code, and automatically update the architecture and source code to maintain their conformance when feature changes occur. We implemented an Eclipse-based toolset to support the approach, and conducted a case study with the Apache Solr open-source system. The result shows that our approach is both applicable and capable to support the development and evolution of real-world variations of a software system.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Design Method\": \"A method for designing software architectures, e.g., to obtain specific qualities or functions.\"}, \"Research Object\": [\"Architecture Design Method\"]}\n"}
{"prompt":"Quality Evaluation of PaaS Cloud Application Design Using Generated Prototypes\n\nWith the increasing popularity of Platform as a Service (PaaS) cloud, software architects need to face new challenges of software architecture design, efficiently integrating the benefits of PaaS services. In this respect, early quality evaluation of the designed PaaS cloud application is crucial to mitigate the risk of later architectural changes due to violation of quality requirements (such as throughput, response time and scalability). Despite the emergence of architectural tactics and patterns usable for the design of PaaS cloud applications, it is challenging for the software architects to navigate in a rich set of offered services, variability of the PaaS cloud environment and quality conflicts in existing tactics, which makes it almost impossible to predicts the overall application quality without time-consuming implementation of application prototypes. In this paper, we take advantage of the cloud elasticity and introduce a design-time quality evaluation technique for PaaS applications based on automatically generated application prototypes, which are deployed to the cloud and repeatedly evaluated in the context of multiple quality attributes and environment configurations. As part of this work, we present an abstract application model designed to carefully select the details with high performance impact, and present the implementation of our tool generating the prototypes of PaaS cloud applications.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Analysis Method\": \"A method for analyzing existing software architectures, e.g., to measure or evaluate specific qualities or functions.\"}, \"Research Object\": [\"Architecture Analysis Method\"]}\n"}
{"prompt":"An Architecture Framework for Modelling and Simulation of Situational-Aware Cyber-Physical Systems\n\nSituational Aware (SiA) Cyber-physical systems (CPS) harmoniously integrate computational and physical components to being aware of what is happening in the surroundings and using this information to decide and act. Architecture description of SiA-CPS can be a valuable tool to reason about the selected solutions, and to enable code generation and simulation. This paper presents an architecture framework that automatically generates from a SiA-CPS architecture description, an executable code used to simulate the architecture model and evaluate it in terms of data traffic load, battery level and energy consumptions. The framework makes use of a model transformation approach where, three SiA-CPS domain-specific modeling views are automatically transformed into the input language of CupCarbon, an open source tool supporting the simulation of sensor network architectures.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Design Method\": \"A method for designing software architectures, e.g., to obtain specific qualities or functions.\"}, \"Research Object\": [\"Architecture Design Method\"]}\n"}
{"prompt":"Formally Describing Self-organizing Architectures for Systems-of-Systems on the Internet-of-Things\n\nNowadays, the Internet-of-Things (IoT) enables the engineering of Software-intensive Systems-of-Systems (SoS), which are opportunistically created for achieving specified missions in specific operational environments. A challenging issue in the architectural design of SoS on IoT is to conceive concepts and mechanisms for describing how an SoS architecture is able to create, on the fly, emergent behaviors from elementary IoT systems\/devices. To address this challenge, this paper investigates the theory of self-organization, which makes possible that, in an SoS, its constituent systems spontaneously create and maintain a valid SoS architecture enabling the evolutionary development of the required emergent behavior to fulfill the specified SoS mission. In particular, it describes how SosADL, a formal SoS Architecture Description Language (ADL), based on the novel \u03c0-Calculus for SoS, was enhanced to support the architectural description of self-organizing SoSs on the IoT, upwardly causing SoS emergent behaviors at run-time.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Description Language\": \"A formal or software language to create a description of a software architecture, i.e., \\\"any form of expression for use in architecture descriptions\\\" [ISO\/IEC 42010]. Papers propose or extend an existing architecture description language.\"}, \"Research Object\": [\"Architecture Description Language\"]}\n"}
{"prompt":"Architectural Patterns for Cross-Domain Personalised Automotive Functions\n\nContext: Future automotive customer functions will be highly personalisable and adapt their settings proactively in an intelligent way. Aim: We aim at designing generic architectural patterns for functional architectures containing machine learning components. Method: We first formalise a new architectural model. Based on this model, we present and discuss three alternative architectural patterns: (1) concurrent learning, (2) end-to-end learning, and (3) user shadow learning. For these patterns, three alternative integration approaches are discussed: (i) centralised holistic approach, (ii) domain-specific approach, and (iii) dedicated approach. Moreover, we conduct an evaluation using real car data for different customer functions. Conclusion: We propose the use of the user shadow learning pattern in the dynamic architectural model. The user shadow learning pattern is not affected by safety constraints, as is usually the case for integrating artificial intelligence, as it only models user behaviour while leaving the original function intact. To integrate the multitude of models, we propose a domain-specific approach. This approach provides a balance between the trade-offs in the dedicated approach and the holistic approach, being high computational overhead and design complexity, respectively.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Pattern\": \"An architectural pattern is a general, reusable solution to a commonly occurring problem in software architecture within a given context. Patterns with negative effects on the product, i.e., anti-patterns, are also included here.\"}, \"Research Object\": [\"Architecture Pattern\"]}\n"}
{"prompt":"Semantic Differencing for Message-Driven Component {\\&} Connector Architectures\n\nStepwise refinement is a development methodology in which software components progressively evolve under strict adherence of proven properties. This requires means to check whether a new version of a component - with potentially different interface and behavior implementation - refines the behavior of its predecessor. Where architecture description languages (ADLs) support refinement checking, the complexity of their semantic domain requires (partially) manual proving to establish refinement between component versions. We identified a subset of the FOCUS semantics for describing distributed systems as stream processing functions that is powerful enough to model complex and realistic systems, yet sufficiently powerful to support fully automated refinement checking. Leveraging this, we present a refinement checking method for ADLs yielding semantics that can be expressed as stream processing functions. This method relies on transforming architectures into composed port automata and translating these to Buchi automata prior to proving refinement using RABIT for language inclusion checking. This method enables to compare the behaviors of component versions with minimal effort, yields witnesses for non-refining component pairs, and, thus, ultimately facilitates stepwise component refinement.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Analysis Method\": \"A method for analyzing existing software architectures, e.g., to measure or evaluate specific qualities or functions.\", \"Architecture Description Language\": \"A formal or software language to create a description of a software architecture, i.e., \\\"any form of expression for use in architecture descriptions\\\" [ISO\/IEC 42010]. Papers propose or extend an existing architecture description language.\"}, \"Research Object\": [\"Architecture Description Language\", \"Architecture Analysis Method\"]}\n"}
{"prompt":"A Platform for the Automated Provisioning of Architecture Information for Large-Scale Service-Oriented Software Systems\n\nProviding valid architecture information to stakeholders remains a challenge, as the effort required for documenting and maintaining this information over a longer period of time is very high. Automatically and continuously extracting architecture information from the system implementation makes it possible to document and keep architecture information up-to-date. In large software systems, architecture extraction has to deal with the continuous and efficient extraction of architectural information from very large code bases. In cooperation with a company from the financial sector, we have developed over several years a platform for the automatic extraction and provision of architectural information for large-scale service-oriented software systems. The platform was evaluated in a real industrial environment. The results of this evaluation show that it can provide up-to-date architectural information for large code bases on a daily basis. It also provides information on the trustworthiness of the extracted information and how it can be improved.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Extraction\": \"Designing and realizing methods and algorithms to automatically extract architecture information from existing implementations.\"}, \"Research Object\": [\"Architecture Extraction\"]}\n"}
{"prompt":"{COCOS:} {A} Scalable Architecture for Containerized Heterogeneous Systems\n\nNowadays software systems are organized around several and heterogeneous components. For example, a modern application can be composed of different microservices, along with dedicated components for machine learning analytics and recurring batch processing jobs. While containers offer a means to deploy the system and tackle heterogeneity, these components have different execution models, can exploit different resource types (e.g., CPUs and GPUs) and result in completely different execution times (milliseconds vs hours). This complexity calls for a new, scalable architecture to allow the systems to operate efficiently. This paper presents COCOS, an architecture, based on containers and control-theory, that is able to manage large and heterogeneous software systems. The architecture is based on a three-level hierarchy of controllers that cooperatively enforce user-defined requirements on execution times and consumed resources. The paper also shows a prototype implementation of COCOS based on Kubernetes, a well-known container orchestrator. The evaluation shows the efficiency of COCOS when dealing with microservices, Spark jobs and machine learning applications.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Reference Architecture\": \"A description of an architecture (e.g., domain-specific or to solve recurring problems) that can be tailored to specific use cases.\"}, \"Research Object\": [\"Reference Architecture\"]}\n"}
{"prompt":"Assessing Adaptability of Software Architectures for Cyber Physical Production Systems\n\nCyber physical production systems (CPPS) focus on increasing the flexibility and adaptability of industrial production systems, systems that comprise hardware such as sensors and actuators in machines as well as software controlling and integrating these machines. The requirements of customised mass production imply that control software needs to be adaptable after deployment in a shop floor, possibly even without interrupting production. Software architecture plays a central role in achieving run-time adaptability. In this paper we describe five architectures, that define the structure and interaction of software components in CPPS. Three of them already are already well known and used in the field. The other two we contribute as possible solution to overcome limitations of the first three architectures. We analyse the architectures\u2019 ability to support adaptability based on Taylor et al.\u2019s BASE framework. We compare the architectures and discuss how the implications of CPPS affect the analysis with BASE. We further highlight what lessons from \u201ctraditional\u201d software architecture research can be applied to arrive at adaptable software architectures for cyber physical production systems.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Reference Architecture\": \"A description of an architecture (e.g., domain-specific or to solve recurring problems) that can be tailored to specific use cases.\"}, \"Research Object\": [\"Reference Architecture\"]}\n"}
{"prompt":"ECo-IoT: An Architectural Approach for Realizing Emergent Configurations in the Internet of Things\n\nThe rapid proliferation of the Internet of Things (IoT) is changing the way we live our everyday life and the society in general. New devices get connected to the Internet every day and, similarly, new IoT services and applications exploiting them are developed across a wide range of domains. The IoT environment typically is very dynamic, devices might suddenly become unavailable and new ones might appear. Similarly, users enter and\/or leave the IoT environment while being interested in fulfilling their individual needs. These key aspects must be considered while designing and realizing IoT systems. In this paper we propose ECo-IoT, an architectural approach to enable the automated formation and adaptation of Emergent Configurations (ECs) in the IoT. An EC is formed by a set of things, with their services, functionalities, and applications, to realize a user goal. ECs are adapted in response to (un)foreseen context changes e.g., changes in available things or due to changing or evolving user goals. In the paper, we describe: (i) an architecture and a process for realizing ECs; and (ii) a prototype we implemented for (iii) the validation of ECo-IoT through an IoT scenario that we use throughout the paper.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Description\": \"An Architecture Description (AD) is a work product used to express the Architecture of some System Of Interest. An AD describes one possible Architecture for a System Of Interest. An AD may take the form of a document, a set of models, a model repository, or some other form [ISO\/IEC 42010]. Papers use existing architecture description languages to describe architectures.\"}, \"Research Object\": [\"Architecture Description\"]}\n"}
