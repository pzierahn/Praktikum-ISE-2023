{"prompt":"Architecture-Based Change Impact Analysis in Information Systems and Business Processes\n\nBusiness processes as well as software systems face various changes during their lifetime. As they mutually influence each other, business processes and software systems have to be modified in co-evolution. Thus, to adequately predict the change impact, it is important to consider the complex mutual dependencies of both domains. However, existing approaches are limited to analyzing the change propagation in software systems or business processes in isolation. In this paper, we present a tool-supported approach to estimate the change propagation caused by a change request in business processes or software systems based on the software architecture and the process design. We focus on the mutual dependencies regarding the change propagation between both domains. In the evaluation, we apply our approach to a community case study to demonstrate the quality of results in terms of precision, recall, and coverage.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Analysis Method\": \"A method for analyzing existing software architectures, e.g., to measure or evaluate specific qualities or functions.\"}, \"Research Object\": [\"Architecture Analysis Method\"]}\n"}
{"prompt":"A Taxonomy of Blockchain-Based Systems for Architecture Design\n\nBlockchain is an emerging technology for decentralised and transactional data sharing across a large network of untrusted participants. It enables new forms of distributed software architectures, where agreement on shared states can be established without trusting a central integration point. A major difficulty for architects designing applications based on blockchain is that the technology has many configurations and variants. Since blockchains are at an early stage, there is little product data or reliable technology evaluation available to compare different blockchains. In this paper, we propose how to classify and compare blockchains and blockchain-based systems to assist with the design and assessment of their impact on software architectures. Our taxonomy captures major architectural characteristics of blockchains and the impact of their principal design decisions. This taxonomy is intended to help with important architectural considerations about the performance and quality attributes of blockchain-based systems.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Decision Making\": \"In software development and evolution, decision-making is an integral part. Various decisions are being made throughout the software development life cycle concerning processes, products, tools, methods, and techniques. From a decision-making perspective, all these questions are confronted by different objectives and constraints, a huge number of variables under dynamically changing requirements, processes, actors, stakeholders, tools, and techniques. This is combined with incomplete, fuzzy or inconsistent information about all the involved artifacts. [Ruhe2003]\"}, \"Research Object\": [\"Architecture Decision Making\"]}\n"}
{"prompt":"An Exploratory Study of Naturalistic Decision Making in Complex Software Architecture Environments\n\nArchitects always make decisions in some context. That context shifts and changes dynamically. Different decision-making strategies are appropriate in different contexts. Architecture decisions are at times made under conditions of time pressure, high stakes, uncertainty, and with too little information. At other times, decision-makers have sufficient time to reflect on the decision and consider alternatives. Understanding context is critical to choosing appropriate approaches to architecture decision making. Naturalistic Decision Making (NDM) explains how people make decisions under real-world conditions. This paper investigates NDM in software architecture and studies architecture decisions in their environment and decision-making context. The research approach includes a case study of large technology organizations consisting of a survey, multiple focus groups, and participant observation. Previous studies that touch on NDM in software architecture have mainly focused on decision-making processes or tools or developing decision models. This paper provides three contributions. First, we build on previous studies by other researchers to produce an in-depth exploration of NDM in the context of software architecture. We focus on Recognition-Primed Decision (RPD) making as an implementation of NDM. Second, we present an examination of the decisions made by experienced architects under conditions that can be considered naturalistic. Third, we provide examples and recommendations that help software architects determine when an NDM approach is appropriate for their context.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Decision Making\": \"In software development and evolution, decision-making is an integral part. Various decisions are being made throughout the software development life cycle concerning processes, products, tools, methods, and techniques. From a decision-making perspective, all these questions are confronted by different objectives and constraints, a huge number of variables under dynamically changing requirements, processes, actors, stakeholders, tools, and techniques. This is combined with incomplete, fuzzy or inconsistent information about all the involved artifacts. [Ruhe2003]\"}, \"Research Object\": [\"Architecture Decision Making\"]}\n"}
{"prompt":"Automatic Extraction of Design Decisions from Issue Management Systems: {A} Machine Learning Based Approach\n\nThe need to explicitly document design decisions has been emphasized both in research and in industry. To address design concerns, software architects and developers implicitly capture design decisions in\u00a0tools such as issue management systems. These design decisions are not explicitly labeled and are not integrated with the architecture knowledge management tools. Automatically extracting design decisions will aid architectural knowledge management tools to learn from the past decisions and to guide architects while making decisions in similar context. In this paper, we propose a two-phase supervised machine learning based approach to first, automatically detect design decisions from issues and second, to automatically classify the identified design decisions into different decision categories. We have manually analyzed and labeled more than 1,500 issues from two large open source repositories and have used this dataset for generating the machine learning models. We have made the dataset publicly available that will serve as a starting point for researchers to further reference and investigate the design decision detection and classification problem. Our evaluation shows that by using linear support vector machines, we can detect design decisions with 91.29% accuracy and classify them with an accuracy of 82.79%. This provides a quantitative basis for learning from past design decisions to support stakeholders in making better and informed design decisions.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Analysis Method\": \"A method for analyzing existing software architectures, e.g., to measure or evaluate specific qualities or functions.\"}, \"Research Object\": [\"Architecture Analysis Method\"]}\n"}
{"prompt":"Butterfly Space: An Architectural Approach for Investigating Performance Issues\n\nPerformance issues widely exist in modern software systems. Existing performance optimization approaches, such as dynamic profiling, usually fail to consider the impacts of architectural connections among methods on performance issues. This paper contributes an architectural approach, Butterfly Space modeling, to investigate performance issues. Each Butterfly Space is composed of 1) a seed method; 2) methods in the \"upper wing\" that call the seed directly or transitively; and 3) methods in the \"lower wing\" that are called by the seed, directly or transitively. The rationale is that the performance of the seed method impacts and is impacted by all the other methods in the space because of the call relationship. As such, developers can more efficiently investigate groups of connected performance improvement opportunities in Butterfly Spaces. We studied three real-world open source Java projects to evaluate such potential. Our findings are three-fold: 1) If the seed method of a Butterfly Space contains performance problems, up to 60% of the methods in the space also contain performance problems; 2) Butterfly Spaces can potentially help to non-trivially increase the precision\/recall and reduce the costs in identifying performance improvement opportunities, compared to dynamic profiling; and 3) Visualizing dynamic profiling metrics with Butterfly Spaces simultaneously help to reveal two typical patterns, namely Expensive Callee and Inefficient Caller, that are responsible for performance problems and provide insights on where to improve next. We believe that Butterfly Space modeling has great potential for investigating performance issues.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architectural Aspects\": \"A method for identifying or specifying specific architectural aspects in existing implemented architectures, e.g., automatically identifying transactional contexts in an architecture. Note that if you analyze an architecture description containing these aspects, the analysis is a separate research object.\", \"Architecture Analysis Method\": \"A method for analyzing existing software architectures, e.g., to measure or evaluate specific qualities or functions.\"}, \"Research Object\": [\"Architecture Analysis Method\", \"Architectural Aspects\"]}\n"}
{"prompt":"Applying Architecture-Based Adaptation to Automate the Management of Internet-of-Things\n\nArchitecture-based adaptation equips a software-intensive system with a feedback loop that enables the system to adapt itself at runtime to changes to maintain its required quality goals. To guarantee the required goals, existing adaptation approaches apply exhaustive verification techniques at runtime. However these approaches are restricted to small-scale settings, which often limits their applicability in practice. To tackle this problem, we introduce an innovative architecture-based adaptation approach to solve a concrete practical problem of VersaSense: automating the management of Internet-of-Things (IoT). The approach, called MARTAS, equips a software system with a feedback loop that employs Models At Run Time and Statistical techniques to reason about the system and adapt it to ensure the required goals. We apply MARTAS to a building security case system, which is a representative IoT system deployed by VersaSense. The application comprises a set of IoT devices that communicate sensor data over a time synchronized smart mess network to a central monitoring facility. We demonstrate how MARTAS outperforms a conservative approach that is typically applied in practice and a state-of-the-art adaptation approach for different quality goals, and we report lessons learned from this industrial case.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Optimization Method\": \"A method to optimize existing architectures (implemented or designed) regarding specific qualities or properties.\"}, \"Research Object\": [\"Architecture Optimization Method\"]}\n"}
{"prompt":"Microservice Ambients: An Architectural Meta-Modelling Approach for Microservice Granularity\n\nIsolating fine-grained business functionalities byboundaries into entities called microservices is a core activityunderlying microservitization. We define microservitization asthe paradigm shift towards microservices. Determining theoptimal microservice boundaries (i.e. microservice granularity) is among the key microservitization design decisions thatinfluence the Quality of Service (QoS) of the microservice applicationat runtime. In this paper, we provide an architecturecentricapproach to model this decision problem. We build onambients - a modelling approach that can explicitly capturefunctional boundaries and their adaptation. We extend the aspect-oriented architectural meta-modelling approach of ambients-AMBIENT-PRISMA - with microservice ambients. A microservice ambient is a modelling concept that treatsmicroservice boundaries as an adaptable first-class entity. Weuse a hypothetical online movie subscription-based systemto capture a microservitization scenario using our aspectorientedmodelling approach. The results show the ability ofmicroservice ambients to express the functional boundary of amicroservice, the concerns of each boundary, the relationshipsacross boundaries and the adaptations of these boundaries. Additionally, we evaluate the expressiveness and effectivenessof microservice ambients using criteria from ArchitectureDescription Language (ADL) classification frameworkssince microservice ambients essentially support architecturedescription for microservices. The evaluation focuses on thefundamental modelling constructs of microservice ambientsand how they support microservitization properties such asutility-driven design, tool heterogeneity and decentralised governance. The evaluation highlights how microservice ambientssupport analysis, evolution and mobility\/location awarenesswhich are significant to quality-driven microservice granularityadaptation. The evaluation is general and irrespective of theparticular application domain and the business competenciesin that domain.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Design Method\": \"A method for designing software architectures, e.g., to obtain specific qualities or functions.\"}, \"Research Object\": [\"Architecture Design Method\"]}\n"}
{"prompt":"Continuous Integration Impediments in Large-Scale Industry Projects\n\nBased on interviews with 20 developers from two case study companies that develop large-scale software-intensive embedded systems, this paper presents the main factors that affect how often developers deliver software to the mainline. Further on, the paper describes the continuous integration behaviors in projects where up to 1,000 developers commit to the same mainline. The main factors that could enable more frequent integration of software are: \"Activity planning and execution\", \"System thinking\", \"Speed\" and \"Confidence through test activities\". Behind these main themes we also present a wide range of sub-categories (\"Modular and loosely coupled architecture\", \"Test selection\" etc) which summarizes what the developers themselves see as the continuous integration impediments in large-scale industry projects.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architectural Aspects\": \"A method for identifying or specifying specific architectural aspects in existing implemented architectures, e.g., automatically identifying transactional contexts in an architecture. Note that if you analyze an architecture description containing these aspects, the analysis is a separate research object.\"}, \"Research Object\": [\"Architectural Aspects\"]}\n"}
{"prompt":"Employment of Optimal Approximations on Apache Hadoop Checkpoint Technique for Performance Improvements\n\nThe Checkpoint and Recovery (CR) technique is widely used due to its fault tolerance efficiency. The Apache Hadoop framework uses this technique as a way to avoid failures in its distributed file system. However, determining the optimal interval between successive checkpoints is a challenge, mainly inside Hadoop as it does not allow real-time modifications. The Dynamic Configuration Architecture (DCA) was created to solve this issue by enabling changes in the checkpoint period without any interruption of the Hadoop services. This paper presents improvements for the DCA through the configuration of the Hadoop checkpoint period in real-time based on optimal period approximations that were already endorsed by the literature. The proposed improvement depends on the tracking of the system resources. The data collected from these resources are stored in a history of attributes: a tree of monitored elements where data is updated as new observations are experienced in the system. This feature enables the user to estimate system factors so that our solution computes the checkpoints costs and the mean time between failures (MTBF). For the validation, experiments with transient failure in the NameNode were created and the usage of the history of attributes was tested in different scenarios. The evaluation results show that an adaptive configuration of checkpoint periods reduces the wasted time caused by failures in the NameNode and improves Hadoop performance. Also, the history of attributes demonstrated its value by providing an efficient way to estimate the system factors.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Optimization Method\": \"A method to optimize existing architectures (implemented or designed) regarding specific qualities or properties.\"}, \"Research Object\": [\"Architecture Optimization Method\"]}\n"}
{"prompt":"{REST} vs GraphQL: {A} Controlled Experiment\n\nGraphQL is a novel query language for implementing service-based software architectures. The language is gaining momentum and it is now used by major software companies, such as Facebook and GitHub. However, we still lack empirical evidence on the real gains achieved by GraphQL, particularly in terms of the effort required to implement queries in this language. Therefore, in this paper we describe a controlled experiment with 22 students (10 undergraduate and 12 graduate), who were asked to implement eight queries for accessing a web service, using GraphQL and REST. Our results show that GraphQL requires less effort to implement remote service queries when compared to REST (9 vs 6 minutes, median times). These gains increase when REST queries include more complex endpoints, with several parameters. Interestingly, GraphQL outperforms REST even among more experienced participants (as is the case of graduate students) and among participants with previous experience in REST, but no previous experience in GraphQL.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Design Method\": \"A method for designing software architectures, e.g., to obtain specific qualities or functions.\"}, \"Research Object\": [\"Architecture Design Method\"]}\n"}
{"prompt":"Enforcing Architectural Security Decisions\n\nSoftware architects should specify security measures for a software system on an architectural level. However, the implementation often diverges from this intended architecture including its security measures. This may lead to severe vulnerabilities that have a wide impact on the system and are hard to fix afterwards. In this paper, we propose an approach for checking the implementation's conformance with the defined security measures using architectural security rules: We extend a controlled natural language approach to formalize these rules and use dynamic analysis techniques to extract information on the actual system behavior for the conformance check. We evaluate our approach by an industrial case study to show the applicability and flexibility of our conformance checking approach.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Analysis Method\": \"A method for analyzing existing software architectures, e.g., to measure or evaluate specific qualities or functions.\"}, \"Research Object\": [\"Architecture Analysis Method\"]}\n"}
{"prompt":"A Decision Model for Choosing Patterns in Blockchain-Based Applications\n\nBlockchains have been applied in different domains to guarantee data integrity and provide a decentralized computational infrastructure for executing smart contracts. Multiple blockchain-related patterns have been summarized by academics and industry practitioners covering different aspects, such as engineering applications on top of a blockchain, structuring smart contracts, and security. The existence of these patterns is both helpful and challenging for designers. Helpful, as the existence of these patterns means that developers do not need to recreate solutions to common problems. Challenging, as the multitude of patterns leaves a designer confused about when to adopt or adapt patterns. In this paper, we propose a decision model that assists developers and architects in selecting appropriate patterns for blockchain-based applications. The selection is based on the characteristics of the use cases and trade-offs implicit in the patterns. We evaluated the proposed decision model based on expert opinion regarding its correctness and usefulness in guiding the architecture design and understanding the rationale of various design decisions.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Decision Making\": \"In software development and evolution, decision-making is an integral part. Various decisions are being made throughout the software development life cycle concerning processes, products, tools, methods, and techniques. From a decision-making perspective, all these questions are confronted by different objectives and constraints, a huge number of variables under dynamically changing requirements, processes, actors, stakeholders, tools, and techniques. This is combined with incomplete, fuzzy or inconsistent information about all the involved artifacts. [Ruhe2003]\"}, \"Research Object\": [\"Architecture Decision Making\"]}\n"}
{"prompt":"InMap: Automated Interactive Code-to-Architecture Mapping Recommendations\n\nReflexion Modelling is a popular method used in industry for Software Architectural Consistency Checking (SACC). However, it involves a mapping step that is manual and tedious. There exist techniques and tools that attempt to automate mapping, yet they are either limited in their approach or they require an initial set of manually pre-mapped entities. This study proposes a novel technique, InMap, that improves the mapping process in reflexion modelling by both providing versatility and eliminating the constraint of needing a set of manually pre-mapped entities in order to automate mapping. Using a software\u2019s architecture descriptions, InMap applies information retrieval concepts to the software\u2019s source code to interactively provide mapping recommendations to an architect. For the six systems InMap was evaluated on, the recommendations it provided achieved an average recall of 0.97, and an average precision of 0.82. InMap also achieved higher, f\n<inf xmlns:mml=\"http:\/\/www.w3.org\/1998\/Math\/MathML\" xmlns:xlink=\"http:\/\/www.w3.org\/1999\/xlink\">1<\/inf>\n-scores in comparison to existing techniques that require premapping. This provides a basis for improving industry tools that use reflexion modelling or similar SACC methods.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Optimization Method\": \"A method to optimize existing architectures (implemented or designed) regarding specific qualities or properties.\"}, \"Research Object\": [\"Architecture Optimization Method\"]}\n"}
{"prompt":"Synchronous Reconfiguration of Distributed Embedded Applications During Operation\n\nSpeed of adaptation to changing demand is a critical success factor in factory automation. The key to speed is to enable agile development by independent engineer offices and equipment producers with industrial-grade microservice architectures. The expensive drawback is: While software components evolve over time, manufacturers have to integrate and deploy more and more updates during costly production stops. To avoid production stops as much as possible, we propose reconfiguration extensions to a real-time container architecture proposed earlier. The original container approach addresses both the functional and nonfunctional aspects of integrating embedded software components in late engineering phases. The extended approach allows modifications of the running distributed embedded application even during operation, while continuously ensuring reactivity of the system. The agents running on each node prepare the reconfiguration in background and then synchronously perform the required modifications according to a detailed reconfiguration plan. We demonstrate our concept by describing a synchronous API change between two distributed software components of a running gesture recognition system. An evaluation shows the feasibility of the concepts, but also calls for further research.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architectural Aspects\": \"A method for identifying or specifying specific architectural aspects in existing implemented architectures, e.g., automatically identifying transactional contexts in an architecture. Note that if you analyze an architecture description containing these aspects, the analysis is a separate research object.\"}, \"Research Object\": [\"Architectural Aspects\"]}\n"}
{"prompt":"Towards Micro Service Architecture Recovery: An Empirical Study\n\nMicro service architectures are rapidly establishing themselves in the software industry as a more efficient and effective substitute for monolithic applications. In a micro service architecture, the application is broken down into many small elements called micro services. These are managed in a distributed way and typically involve several development teams. In such an environment, an architectural model can get lost along the way, making it difficult to perform many downstream software engineering tasks, such as migration, audit, integration or impact analysis. To address this problem, we are developing support for Micro Service Architecture Recovery (MiSAR) using a Model Driven Engineering approach. In this paper, we describe an empirical study which aims to identify the core elements of our approach, by undertaking manual analysis on 8 micro service-based open source projects. From this analysis, we define a metamodel for micro service-based architectures and a set of mapping rules which map between the software and the metamodel. The resulting metamodel and mapping rules provide a solid foundation for any micro service architecture recovery approach and hence are a key first step towards managing the architectural integrity of micro service-based applications.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Extraction\": \"Designing and realizing methods and algorithms to automatically extract architecture information from existing implementations.\"}, \"Research Object\": [\"Architecture Extraction\"]}\n"}
{"prompt":"Predicting the Performance of Privacy-Preserving Data Analytics Using Architecture Modelling and Simulation\n\nPrivacy-preserving data analytics is an emerging technology which allows multiple parties to perform joint data analytics without disclosing source data to each other or a trusted third-party. A variety of platforms and protocols have been proposed in this domain. However, these systems are not yet widely used, and little is known about them from a software architecture and performance perspective. Here we investigate the feasibility of using architectural performance modelling and simulation tools for predicting the performance of privacy-preserving data analytics systems. We report on a lab-based experimental study of a privacy-preserving credit scoring application that uses an implementation of a partial homomorphic encryption scheme. The main experiments are on the impact of analytic problem size (number of data items and number of features), and cryptographic key length for the overall system performance. Our modelling approach performed with a relative error consistently under 5\\% when predicting the median learning time for the scoring application. We find that the use of this approach is feasible in this technology domain, and discuss how it can support architectural decision making on trade-offs between properties such as performance, cost, and security. We expect this to enable the evaluation and optimisation of privacy-preserving data analytics technologies.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architectural Assumptions\": \"Assumptions are the reasons for architectural decisions that are more or less arbitrarily taken on the fly because of personal experience, background, domain knowledge, the artifacts reused, and the like\"}, \"Research Object\": [\"Architectural Assumptions\"]}\n"}
{"prompt":"Identifying and Prioritizing Architectural Debt Through Architectural Smells: {A} Case Study in a Large Software Company\n\nArchitectural technical debt can have a huge impact on software maintainability and evolution. Hence, different architectural violations, detected as architectural smells, need to be identified and refactored. In this paper, we conducted a multiple case-study on several architectural smells detected in four industrial projects. We conducted an in-depth investigation with a questionnaire, interviews and thorough inspection of the code with the practitioners. We evaluated the negative impact of the technical debt detected by the architectural smells, their difficulty to be refactored and the usefulness of the detection tool. The results show that practitioners appreciated the help of automatic detection, and that they prioritize refactoring architectural debt that causes more negative impact despite the higher refactoring effort.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Pattern\": \"An architectural pattern is a general, reusable solution to a commonly occurring problem in software architecture within a given context. Patterns with negative effects on the product, i.e., anti-patterns, are also included here.\"}, \"Research Object\": [\"Architecture Pattern\"]}\n"}
{"prompt":"{IAS:} An IoT Architectural Self-adaptation Framework\n\nThis paper develops a generic approach to model control loops and their interaction within the Internet of Things (IoT) environments. We take advantage of MAPE-K loops to enable architectural self-adaptation. The system\u2019s architectural setting is aligned with the adaptation goals and the components run-time situation and constraints. We introduce an integrated framework for IoT Architectural Self-adaptation (IAS) where functional control elements are in charge of environmental adaptation and autonomic control elements handle the functional system\u2019s architectural adaptation. A Queuing Networks (QN) approach was used for modeling the IAS. The IAS-QN can model control levels and their interaction to perform both architectural and environmental adaptations. The IAS-QN was modeled on a smart grid system for the Melle-Longchamp area (France). Our architectural adaptation approach successfully set the propositions to enhance the performance of the electricity transmission system. This industrial use-case is a part of CPS4EU European industrial innovation project (CPS4EU is a three years project funded by the H2020-ECSEL-2018-IA. The project develops four vital IoT technologies, namely computing, connectivity, sensing, and cooperative systems. It incorporates those IoT technologies through pre-integrated architectures and design tools. It instantiates the architectures in dedicated use-cases from a strategic application viewpoint for automotive, smart grid, and industrial automation\u00a0\n                  https:\/\/cps4eu.eu\n                  \n                ).\n\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Optimization Method\": \"A method to optimize existing architectures (implemented or designed) regarding specific qualities or properties.\"}, \"Research Object\": [\"Architecture Optimization Method\"]}\n"}
{"prompt":"Recovering Architectural Design Decisions\n\nDesigning and maintaining a software system's architecture typically involve making numerous design decisions, each potentially affecting the system's functional and nonfunctional properties. Understanding these design decisions can help inform future decisions and implementation choices and can avoid introducing regressions and architectural inefficiencies later. Unfortunately, design decisions are rarely well documented and are typically a lost artifact of the architecture creation and maintenance process. The loss of this information can thus hurt development. To address this shortcoming, we develop RecovAr, a technique for automatically recovering design decisions from the project's readily available history artifacts, such as an issue tracker and version control repository. RecovAr uses state-of-the-art architectural recovery techniques on a series of version control commits and maps those commits to issues to identify decisions that affect system architecture. While some decisions can still be lost through this process, our evaluation on Hadoop and Struts, two large open-source systems with over 8 years of development each and, on average, more than 1 million lines of code, shows that RecovAr has the recall of 75% and a precision of 77%. Our work formally defines architectural design decisions and develops an approach for tracing such decisions in project histories. Additionally, the work introduces methods to classify whether decisions are architectural and to map decisions to code elements. Finally, our work contributes a methodology engineers can follow to preserve design-decision knowledge in their projects.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Decision Making\": \"In software development and evolution, decision-making is an integral part. Various decisions are being made throughout the software development life cycle concerning processes, products, tools, methods, and techniques. From a decision-making perspective, all these questions are confronted by different objectives and constraints, a huge number of variables under dynamically changing requirements, processes, actors, stakeholders, tools, and techniques. This is combined with incomplete, fuzzy or inconsistent information about all the involved artifacts. [Ruhe2003]\"}, \"Research Object\": [\"Architecture Decision Making\"]}\n"}
{"prompt":"Tool Support for the Migration to Microservice Architecture: An Industrial Case Study\n\nWith the introduction of microservice architecture, many investigate how to migrate their legacy systems into this architectural paradigm. The migration process requires the recovery of the project architecture to be migrated together with the knowledge necessary to understand how to decompose the code and obtain new microservices. At the moment, this process is realized mostly manually. This paper introduces an approach to identify candidate microservices in monolithic Java projects, implemented in a tool named Arcan and the validation of the approach in an industrial setting. The approach involves static analysis of the system architecture, architectural smell detection and topic detection, a text mining method used here to model software domains starting from code analysis. We report the feedbacks we get from an experienced industrial developer who carried out the migration described in the case study. From this collaboration with industry we collected useful information to enhance the approach, improve the tool and replicate the study.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Analysis Method\": \"A method for analyzing existing software architectures, e.g., to measure or evaluate specific qualities or functions.\", \"Architecture Extraction\": \"Designing and realizing methods and algorithms to automatically extract architecture information from existing implementations.\"}, \"Research Object\": [\"Architecture Extraction\", \"Architecture Analysis Method\"]}\n"}
{"prompt":"Design Criteria to Architect Continuous Experimentation for Self-Driving Vehicles\n\nThe software powering today's vehicles surpasses mechatronics as the dominating engineering challenge due to its fast evolving and innovative nature. In addition, the software and system architecture for upcoming vehicles with automated driving functionality is already processing ~750MB\/s - corresponding to over 180 simultaneous 4K-video streams from popular video-on-demand services. Hence, self-driving cars will run so much software to resemble \"small data centers on wheels\" rather than just transportation vehicles. Continuous Integration, Deployment, and Experimentation have been successfully adopted for software-only products as enabling methodology for feedback-based software development. For example, a popular search engine conducts ~250 experiments each day to improve the software based on its users' behavior. This work investigates design criteria for the software architecture and the corresponding software development and deployment process for complex cyber-physical systems, with the goal of enabling Continuous Experimentation as a way to achieve continuous software evolution. Our research involved reviewing related literature on the topic to extract relevant design requirements. The study is concluded by describing the software development and deployment process and software architecture adopted by our self-driving vehicle laboratory, both based on the extracted criteria.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Design Method\": \"A method for designing software architectures, e.g., to obtain specific qualities or functions.\"}, \"Research Object\": [\"Architecture Design Method\"]}\n"}
{"prompt":"On Cognitive Biases in Architecture Decision Making\n\n\nThe research carried out to date shows that architectural decision-making is far from being a rational process. Architects tend to adopt a satisfying approach, rather than looking for the optimal architecture, which is a result of many human and social factors. The results of a workshop, carried out with 14 software engineering practitioners show that cognitive biases are commonly present in architecture decision-making. A systematic approach to analysing the influence of biases on decision making has been introduced. Twelve cognitive biases identified during the workshop were analysed with regard to the elements of the decision-making context that affected the aspects of architectural decision making. Finally, we analyse the interactions between cognitive biases and the conditions of real-world software development.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Decision Making\": \"In software development and evolution, decision-making is an integral part. Various decisions are being made throughout the software development life cycle concerning processes, products, tools, methods, and techniques. From a decision-making perspective, all these questions are confronted by different objectives and constraints, a huge number of variables under dynamically changing requirements, processes, actors, stakeholders, tools, and techniques. This is combined with incomplete, fuzzy or inconsistent information about all the involved artifacts. [Ruhe2003]\"}, \"Research Object\": [\"Architecture Decision Making\"]}\n"}
{"prompt":"Exploiting Architecture\/Runtime Model-Driven Traceability for Performance Improvement\n\nModel-Driven Engineering techniques may achieve a major support to the software development when they allow to manage relationships between a running system and its architectural model. These relationships can be exploited for different goals, such as the software evolution due to new functional requirements. In this paper, we define and use relationships that work as support to the performance improvement of a running system. In particular, we combine: (i) a bidirectional model transformation framework tailored to define relationships between performance monitoring data and an architectural model, with (ii) a technique for detecting performance antipatterns and for suggesting architectural changes, aimed at removing performance problems identified on the basis of runtime information. The result is an integrated approach that exploits traceability relationships between the monitoring data and the architectural model to derive recommended refactoring solutions for the system performance improvement. The approach has been applied to an e-commerce application based on microservices that has been designed by means of UML software models profiled with MARTE.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Analysis Method\": \"A method for analyzing existing software architectures, e.g., to measure or evaluate specific qualities or functions.\", \"Architecture Design Method\": \"A method for designing software architectures, e.g., to obtain specific qualities or functions.\"}, \"Research Object\": [\"Architecture Analysis Method\", \"Architecture Design Method\"]}\n"}
{"prompt":"Improving the Search for Architecture Knowledge in Online Developer Communities\n\nTo make good architecture design decisions, developers need to know suitable architecture solution alternatives. However, with the rapid and continuous increase of solution alternatives (e.g. technologies, patterns, tactics), it is challenging to acquire architecture knowledge and to ensure that this knowledge is up to date. Our goal is to improve how architects search for architecturally relevant information in online developer communities. We developed a new search approach for architecturally relevant information using Stack Overflow as an example of an online developer community. Our search approach differs from a conventional keyword-based search in that it considers semantic information of architecturally relevant concepts in Stack Overflow. We also implemented the search approach as a web-based search engine. To show the effectiveness of the search approach compared to a conventional keyword-based search, we conducted an experiment with 16 practitioners. To ensure realism of the experiment, tasks given to practitioners are based on real scenarios identified in interviews with a different set of practitioners. The experiment showed that the new search approach outperforms a conventional keyword based search.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Decision Making\": \"In software development and evolution, decision-making is an integral part. Various decisions are being made throughout the software development life cycle concerning processes, products, tools, methods, and techniques. From a decision-making perspective, all these questions are confronted by different objectives and constraints, a huge number of variables under dynamically changing requirements, processes, actors, stakeholders, tools, and techniques. This is combined with incomplete, fuzzy or inconsistent information about all the involved artifacts. [Ruhe2003]\"}, \"Research Object\": [\"Architecture Decision Making\"]}\n"}
{"prompt":"An Expert Recommendation System for Design Decision Making: Who Should be Involved in Making a Design Decision?\n\nIn large software engineering projects, designing software systems is a collaborative decision-making process where a group of architects and developers make design decisions on how to address design concerns by discussing alternative design solutions. For the decision-making process, involving appropriate individuals requires objectivity and awareness about their expertise. In this paper, we propose a novel expert recommendation system that identifies individuals who could be involved in tackling new design concerns in software engineering projects. The approach behind the proposed system addresses challenges such as identifying architectural skills, quantifying architectural expertise of architects and developers, and finally matching and recommending individuals with suitable expertise to discuss new design concerns. To validate our approach, a quantitative evaluation of the recommendation system was performed using design decisions from four software engineering projects. The evaluation not only indicates that individuals with architectural expertise can be identified for design decision making but also provides quantitative evidence for the existence of personal experience bias during the decision-making process.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Decision Making\": \"In software development and evolution, decision-making is an integral part. Various decisions are being made throughout the software development life cycle concerning processes, products, tools, methods, and techniques. From a decision-making perspective, all these questions are confronted by different objectives and constraints, a huge number of variables under dynamically changing requirements, processes, actors, stakeholders, tools, and techniques. This is combined with incomplete, fuzzy or inconsistent information about all the involved artifacts. [Ruhe2003]\"}, \"Research Object\": [\"Architecture Decision Making\"]}\n"}
{"prompt":"A Framework for Tunable Anomaly Detection\n\nAs software architecture practice relies more and more on runtime data to inform decisions in continuous experimentation and self-adaptation, it is increasingly important to consider the quality of the data used as input to the different decision-making and prediction algorithms. One issue in data-driven decisions is that real-life data coming from running systems can contain invalid or wrong values which can bias the result of data analysis. Data-driven decision-making should therefore comprise detection and handling of data anomalies as an integral part of the process. However, currently, anomaly detection is either absent in runtime decision-making approaches for continuous experimentation and self-adaptation or difficult to tailor to domain-specific needs. In this paper, we contribute by proposing a framework that simplifies the detection of data anomalies in timeseries-outputs of running systems. The framework is generic, since it can be employed in different domains, and tunable, since it uses expert user input in tailoring anomaly detection to the needs and assumptions of each domain. We evaluate the feasibility of the framework by successfully applying it to detecting anomalies in a real-life timeseries dataset from the traffic domain.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Decision Making\": \"In software development and evolution, decision-making is an integral part. Various decisions are being made throughout the software development life cycle concerning processes, products, tools, methods, and techniques. From a decision-making perspective, all these questions are confronted by different objectives and constraints, a huge number of variables under dynamically changing requirements, processes, actors, stakeholders, tools, and techniques. This is combined with incomplete, fuzzy or inconsistent information about all the involved artifacts. [Ruhe2003]\"}, \"Research Object\": [\"Architecture Decision Making\"]}\n"}
{"prompt":"Anatomy, Concept, and Design Space of Blockchain Networks\n\nBlockchain technologies have been increasingly adopted by enterprises to increase operational efficiency and enable new business models. These enterprise blockchain applications generally run on dedicated blockchain networks due to regulations and security requirements. The design process of these networks involves many decisions and trade-offs that impact security, governance, and performance of applications that run on them. The challenge is further exacerbated by the lack of a common architecture and concept map to communicate about blockchain networks, as blockchain technologies tend to use different concepts and architecture. This paper presents a concept map, an anatomy and the principal dimensions of the design space of blockchain networks. We applied the proposed design space in a case study about designing and deploying a blockchain network for an ad-hoc IoT infrastructure. We found that the design space brought structure to the design process and the analysis of design alternatives. The presented concept map, anatomy and design space are intended to help improve the blockchain network design practice and lay a foundation for future research on the design process and deployment automation of blockchain networks.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Design Method\": \"A method for designing software architectures, e.g., to obtain specific qualities or functions.\"}, \"Research Object\": [\"Architecture Design Method\"]}\n"}
{"prompt":"Data Stream Operations as First-Class Entities in Component-Based Performance Models\n\nData streaming applications are an important class of data-intensive systems. Performance is an essential quality of such systems. It is, for example, expressed by the delay of analysis results or the utilization of system resources. Architecture-level decisions such as the configuration of sources, sinks and operations, their deployment or the choice of technology impact the performance. Current component-based performance prediction approaches cannot accurately predict the performance of those systems, because they do not support the metrics that are specific to data streaming applications and only approximate the behavior of data stream operations instead of expressing it explicitly. In particular, operations that group multiple data events and thus introduce timing dependencies between different calls to the system are not represented sufficiently. In this paper, we present an approach for modeling networks of data stream operations including their parameters with the goal of predicting the performance of the resulting composed data streaming application. The approach is based on a component-based performance model with queueing semantics for processing resources. Our evaluation shows that our model can more accurately express the behavior of the system, resulting in a more expressive performance model compared to a well-encapsulated component-based model without data stream operations.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Analysis Method\": \"A method for analyzing existing software architectures, e.g., to measure or evaluate specific qualities or functions.\", \"Architecture Design Method\": \"A method for designing software architectures, e.g., to obtain specific qualities or functions.\"}, \"Research Object\": [\"Architecture Design Method\", \"Architecture Analysis Method\"]}\n"}
{"prompt":"Determining Microservice Boundaries: {A} Case Study Using Static and Dynamic Software Analysis\n\nA number of approaches have been proposed to identify service boundaries when decomposing a monolith to microservices. However, only a few use systematic methods and have been demonstrated with replicable empirical studies. We describe a systematic approach for refactoring systems to microservice architectures that uses static analysis to determine the system\u2019s structure and dynamic analysis to understand its actual behavior. A prototype of a tool was built using this approach (MonoBreaker) and was used to conduct a case study on a real-world software project. The goal was to assess the feasibility and benefits of a systematic approach to decomposition that combines static and dynamic analysis. The three study participants regarded as positive the decomposition proposed by our tool, and considered that it showed improvements over approaches that rely only on static analysis.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Design Method\": \"A method for designing software architectures, e.g., to obtain specific qualities or functions.\"}, \"Research Object\": [\"Architecture Design Method\"]}\n"}
{"prompt":"Mitigating the Influence of Embedded Software Development Environments and Toolsets {(ESDT)} on Software Architecture\n\nOne of the first tasks in engineering embedded systems is the selection of the hardware; more specifically, the MicroController Units (MCUs). This selection is driven by business, technical, organizational, and legal constraints. Often, the hardware is delivered together with proprietary environments in which the software to be deployed has to be developed. This imposes architecturally significant constraints that are usually communicated inappropriately (in terms of time and format) to the engineering team. Examples are the usage of proprietary data types and programming language constructs (e.g., macros in C) and limitations to the reuse of existing software assets. To overcome this challenge, we propose an approach that has two main constituents: (i) the Embedded System Checklist, which aims at guiding the selection of MCUs according to the architecture constraints; and (ii) the Embedded System ESDT Dependency (SED) Architecture View, which connects the software design view with the technical view, describing hardware-related development environment limitations and their influences on the software architecture. We evaluated the application of these concepts in two industrial projects and show that making these dependencies transparent saves a lot of effort during software system development.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Design Method\": \"A method for designing software architectures, e.g., to obtain specific qualities or functions.\"}, \"Research Object\": [\"Architecture Design Method\"]}\n"}
{"prompt":"Two Architectural Threat Analysis Techniques Compared\n\nIn an initial attempt to systematize the research field of architectural threat analysis, this paper presents a comparative study of two threat analysis techniques. In particular, the controlled experiment presented here compares two variants of Microsoft\u2019s STRIDE. The two variants differ in the way the analysis is performed. In one case, each component of the software system is considered in isolation and scrutinized for potential security threats. In the other case, the analysis has a wider scope and considers the security threats that might occur in a pair of interacting software components. The study compares the techniques with respect to their effectiveness in finding security threats (benefits) as well as the time that it takes to perform the analysis (cost). We also look into other human aspects which are important for industrial adoption, like, for instance, the perceived difficulty in learning and applying the techniques as well as the overall preference of our experimental participants.\n\n\n\n###\n\n","completion":" {\"Explanations\": {\"Architecture Analysis Method\": \"A method for analyzing existing software architectures, e.g., to measure or evaluate specific qualities or functions.\"}, \"Research Object\": [\"Architecture Analysis Method\"]}\n"}
